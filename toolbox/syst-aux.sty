%D \module
%D   [       file=syst-gen,
%D        version=1996.03.20,
%D          title=\CONTEXT\ System Macros,
%D       subtitle=General,
%D         author=Hans Hagen,
%D           date=\currentdate,
%D      copyright={PRAGMA / Hans Hagen \& Ton Otten}]
%C
%C This module is part of the \CONTEXT\ macro||package and is
%C therefore copyrighted by \PRAGMA. See mreadme.pdf for
%C details.

%D Some of the macros will move to syst-obs as they might become
%D obsolete once we've redone the bibliography module. Of course
%D the handy helpers will stay.

%D This is a stripped down combination of:
%D
%D \startitemize
%D \item \type {syst-gen.tex}
%D \item \type {syst-ext.tex}
%D \item \type {syst-new.tex}
%D \stopitemize
%D
%D We keep them around (for \MKII) so you can find comments,
%D experiences, intermediate versions and cleaner variants
%D there (and also non-\ETEX\ variants).
%D
%D Contrary to the older files, we now assume that this one
%D is used in \CONTEXT\ and therefore we might also assume that
%D some basic functionality is available.
%D
%D Some of the macros here are used in the bibliography module. They
%D will be moved to a separate syst module some once the bib module
%D is made \MKIV.

%C Excerpts from the original file. Content has been reworked by
%C Cedric~Mauclair (2010) to work with LaTeX.

%<< —— Scratch variables and configuration stuff ———————————————————— >>

%D The next few macros are needed in case this module is
%D used outside \CONTEXT.

%D \macros
%D   [protecting]
%D   {protect,unprotect}
%D
%D We can shield macros from users by using some special
%D characters in their names. Some characters that are normally
%D no letters and therefore often used are: \type{@}, \type{!}
%D and \type{?}. Before and after the definition of protected
%D macros, we have to change the \CATCODE\ of these characters.
%D This is done by \type{\unprotect} and \type{\protect}, for
%D instance:
%D
%D \starttyping
%D \unprotect
%D \def\!test{test}
%D \protect
%D \stoptyping
%D
%D The defined command \type{\!test} can of course only be
%D called upon when we are in the \type{\unprotect}'ed state,
%D otherwise \TEX\ reads \type{\!} and probably complains
%D loudly about not being in math mode.
%D
%D Both commands can be used nested, but only the \CATCODE\
%D of the outermost level is saved. We make use of
%D an auxilary macro \type{\doprotect} to prevent us from
%D conflicts with existing macro's \type{\protect}. When
%D nesting deeper than one level, the system shows the
%D protection level.

\ifx\protectionlevel\undefined \newcount\protectionlevel \fi

\ifx\protect\undefined
  \def\protect{\writestatus{protection}{too much protection}}
\else
  % a simple version is already defined
\fi

\let\normalprotect\protect % only for latex

%D Although we don't need the \type{%} after commands that
%D don't take arguments, unless lines are obeyed, I decided
%D to put it there as a reminder. I only mention this once.

\ifx\unprotect\undefined

    \chardef\protectionthreshold=10

    \def\saveprotectedcharacters
      {\edef\doprotectcharacters
         {\catcode`\noexpand @\the\catcode`@
          \catcode`\noexpand !\the\catcode`!
          \catcode`\noexpand ?\the\catcode`? }}

    \def\setprotectedcharacters
      {\catcode`@=11
       \catcode`!=11
       \catcode`?=11 }

    \def\unprotect
      {\ifcase\protectionlevel
         \saveprotectedcharacters
         \let\protect\doprotect
       \fi
       \setprotectedcharacters
       \advance\protectionlevel 1
       \ifnum\protectionlevel>\protectionthreshold
         \reportunprotection
       \fi}

    \def\doprotect
      {\ifcase\protectionlevel\or
         \doprotectcharacters
         \let\doprotectcharacters\relax
         \let\protect\normalprotect
       \fi
       \ifnum\protectionlevel>\protectionthreshold
         \reportprotection
       \fi
       \advance\protectionlevel -1 }

    \def\reportunprotection   {\writestatus{protection}{unprotect \protectionstate}}
    \def\reportprotection     {\writestatus{protection}{protect   \protectionstate}}
    \def\reportprotectionstate{\writestatus{protection}{state     \protectionstate}}

    \def\protectionstate
      {\the\protectionlevel
       \ifcase\protectionthreshold
         :\space
         @=\the\catcode`@\space\space
         !=\the\catcode`!\space\space
         ?=\the\catcode`?%
       \fi}

    \ifx\everyeof\undefined
        \let\checkprotection\relax
    \else
        \def\checkprotection{\everyeof{\writestatus{protection}{state: \protectionstate}}}
    \fi

\else

    \let\reportprotectionstate\relax

\fi

%D Now it is defined, we can make use of this very useful
%D macro.

\unprotect

\def\dounprotected#1\par
  {#1\protect}

\def\unprotected
  {\unprotect\dounprotected}


%D \macros
%D   {normalspace}
%D
%D We often need a space as defined in \PLAIN\ \TEX. Because
%D we cannot be sure of \type{\space} is redefined, we define:

\def\normalspace{ }


%D \macros
%D   {scratchcounter,
%D    scratchdimen,scratchskip,scratchmuskip,
%D    scratchbox,
%D    scratchtoks}
%D
%D Because we often need counters on a temporary basis, we
%D define the \COUNTER\ \type{\scratchcounter}. This is a
%D real \COUNTER, and not a pseudo one, as we will meet
%D further on. We also define some other scratch registers.

\chardef\newabovelimit=20

\def\stripnewabove#1%
  {\ifnum10<9#1 #1\else\expandafter\stripnewabove\fi}%

\def\newabove#1#2% \dimen \name
  {#1#2%
   \ifnum\expandafter\stripnewabove\meaning#2>\newabovelimit\else
     \expandafter\newabove\expandafter#1\expandafter#2%
   \fi}

\newabove \newcount   \scratchcounter
\newabove \newdimen   \scratchdimen
\newabove \newskip    \scratchskip
\newabove \newmuskip  \scratchmuskip
\newabove \newtoks    \scratchtoks
          \newbox     \scratchbox

\newdimen\scratchdimenone \newbox\scratchboxone \newcount\scratchcounterone
\newdimen\scratchdimentwo \newbox\scratchboxtwo \newcount\scratchcountertwo


%D \macros
%D   {!!count, !!toks, !!dimen, !!box,
%D    !!width, !!height, !!depth, !!string, !!done}
%D
%D We define some more \COUNTERS\ and \DIMENSIONS. We also
%D define some shortcuts to the local scatchregisters~0, 2, 4,
%D 6 and~8.

%%UNUSED
\newcount\!!counta \newtoks\!!toksa \newdimen\!!dimena \newbox\!!boxa
\newcount\!!countb \newtoks\!!toksb \newdimen\!!dimenb \newbox\!!boxb

%%UNUSED
\let\!!stringa\empty \let\!!stringb\empty

%%UNUSED
\newdimen\!!widtha \newdimen\!!heighta \newdimen\!!deptha
\newdimen\!!widthb \newdimen\!!heightb \newdimen\!!depthb

\newif\ifdone
%%UNUSED
\newif\if!!donea   \newif\if!!doneb

%%UNUSED
\ifx\data\undefined \else \let\data \relax \fi % dep checker

%D Beware: we don't reuse plain counters, too dangerous
%D when <= 20 (e.g. in supp-pdf this messed up things).

\ifx\undefined\zeroskip           \newskip     \zeroskip                   \fi%%UNUSED
\ifx\undefined\zeropoint          \newdimen    \zeropoint                  \fi
\ifx\undefined\zerocount          \newcount    \zerocount                  \fi%%UNUSED
\ifx\undefined\minusone           \newcount    \minusone                   \fi \minusone = -1
\ifx\undefined\minustwo           \newcount    \minustwo                   \fi \minustwo = -2%%UNUSED
\ifx\undefined\plusone            \chardef     \plusone            =     1 \fi
\ifx\undefined\plustwo            \chardef     \plustwo            =     2 \fi%%UNUSED
\ifx\undefined\plusthree          \chardef     \plusthree          =     3 \fi%%UNUSED
\ifx\undefined\plusfour           \chardef     \plusfour           =     4 \fi%%UNUSED
\ifx\undefined\plusfive           \chardef     \plusfive           =     5 \fi%%UNUSED
\ifx\undefined\plusten            \mathchardef \plusten            =    10 \fi%%UNUSED
\ifx\undefined\plushundred        \mathchardef \plushundred        =   100 \fi%%UNUSED
\ifx\undefined\plusthousand       \mathchardef \plusthousand       =  1000 \fi%%UNUSED
\ifx\undefined\plustenthousand    \mathchardef \plustenthousand    = 10000 \fi%%UNUSED
\ifx\undefined\plustwentythousand \mathchardef \plustwentythousand = 20000 \fi%%UNUSED


%D \macros
%D   {s!,c!,e!,p!,v!,@@,??}
%D
%D To save memory, we use constants (sometimes called
%D variables). Redefining these constants can have disastrous
%D results.

%%UNUSED
\def\v!prefix! {v!}           \def\c!prefix! {c!}
\def\s!prefix! {s!}           \def\p!prefix! {p!}

\def\s!next    {next}         \def\s!default {default}
\def\s!dummy   {dummy}        \def\s!unknown {unknown}

\def\s!do      {do}           \def\s!dodo    {dodo}

\def\s!complex {complex}      \def\s!start   {start}
\def\s!simple  {simple}       \def\s!stop    {stop}

\def\s!empty   {empty}

%D \macros
%D   {@EA,@EAEA,@EAEAEA,@EAEAEAEAEAEA,expanded,startexpanded}
%D
%D When in unprotected mode, to be entered with
%D \type{\unprotect}, one can use \type{\@EA} as equivalent
%D of \type{\expandafter}.

\let\@NX\noexpand
\let\@EA\expandafter

\def\@EAEA  {\expandafter\expandafter}
\def\@EAEAEA{\expandafter\expandafter\expandafter}

\def\@EAEAEAEAEAEA{\expandafter\@EAEAEA\expandafter}

%>> Scratch variables and configuration stuff (end) ————————————————— >>
%<< —— Expansion & gobbles —————————————————————————————————————————— >>

%D \macros
%D   {strippedcsname}
%D
%D The next macro can be very useful when using \type{\csname}
%D like in:
%D
%D \starttyping
%D \csname if\strippedcsname\something\endcsname
%D \stoptyping
%D
%D This expands to \type{\ifsomething}.

\ifx\letterbackslash\undefined
  {\catcode`.=0 .catcode`.\ 12 .xdef.letterbackslash{.string\}} % hack
\fi

\def\strippedcsname#1% this permits \strippedcsname{\xxx} and \strippedcsname{xxx}
  {\expandafter\dostrippedcsname\string#1}

\def\dostrippedcsname#1%
  {\if\noexpand#1\letterbackslash\else#1\fi}


%D \macros
%D   {savenormalmeaning}
%D
%D We will use this one in:

\def\savenormalmeaning#1%
  {\ifundefined{normal\strippedcsname#1}%
     \letvalue{normal\strippedcsname#1}#1%
   \fi}

%D Sometimes we pass macros as arguments to commands that
%D don't expand them before interpretation. Such commands can
%D be enclosed with \type{\expanded}, like:
%D
%D \starttyping
%D \expanded{\setupsomething[\alfa]}
%D \stoptyping
%D
%D Such situations occur for instance when \type{\alfa} is a
%D commalist or when data stored in macros is fed to index of
%D list commands. If needed, one should use \type{\noexpand}
%D inside the argument. Later on we will meet some more clever
%D alternatives to this command.

\long\def\@@expanded{} % always long; global (less restores)

\long\def\expanded#1%
  {\long\xdef\@@expanded{\noexpand#1}\@@expanded}

%D Beware, the next one has no \type {\noexpand} before its
%D argument.

\long\def\startexpanded#1\stopexpanded % see x-fo for example
  {\long\xdef\@@expanded{#1}\@@expanded}


%D \macros
%D   {safeexpanded,everysafeexpanded}
%D
%D In addition we provide:

\newtoks\everysafeexpanded

\long\def\safeexpanded#1% why the \noexpand
  {\begingroup
   \the\everysafeexpanded\long\xdef\@@expanded{\noexpand#1}%
   \endgroup
   \@@expanded}

\def\safeedef#1#2%
  {\begingroup
   \the\everysafeexpanded\long\xdef\@@expanded{\noexpand#2}%
   \endgroup
   \let#1\@@expanded}

\def\safexdef#1#2%
  {\begingroup
   \the\everysafeexpanded\long\xdef\@@expanded{\noexpand#2}%
   \endgroup
   \global\let#1\@@expanded}

%D You can append protective measures to the token register if
%D needed, as we will do later.


%D \macros
%D   {donottest,unexpanded}
%D
%D When expansion of a macro gives problems, we can precede it
%D by \type{\donottest}. It seems that protection is one of the
%D burdens of developers of packages, so maybe that's why in
%D \ETEX\ protection is solved in a more robust way.
%D
%D Sometimes prefixing the macro with \type{\donottest} leads
%D to defining an auxiliary macro, like
%D
%D \starttyping
%D \def\dosomecommand {... ... ...}
%D \def\somecommand   {\donottest\dosomecommand}
%D \stoptyping
%D
%D This double definition can be made transparant by using
%D \type{\unexpanded}, as in:
%D
%D \starttyping
%D \unexpanded\def\somecommand{... ... ...}
%D \stoptyping
%D
%D The protection mechanism uses:

\def\dontprocesstest#1{==}
\def\doprocesstest  #1{#1}

\let\donottest=\doprocesstest

%D By the way, we use a placeholder because we don't want
%D interference when testing on empty strings. Using a
%D placeholder of 8~characters increases the processing time
%D of simple \type{\doifelse} tests by about 10 \%. When we
%D process the test, we have to remove the braces and
%D therefore explictly gobble \type{#1}.


%D \macros
%D   {honorunexpanded,forceunexpanded}
%D
%D The fact that many macros have the same prefix, could have
%D a negative impact on searching in the hash table. Because
%D some simple testing does not show differences, we just use:
%D
%D \starttyping
%D \def\unexpanded#1#2%
%D   {\@EA#1\@EA#2\@EA{\@EA\donottest\csname\s!do\string#2\endcsname}%
%D    \@EA#1\csname\s!do\string#2\endcsname}
%D \stoptyping
%D
%D Well, in fact we use the bit more versatile alternative. The
%D \type {\honorunexpanded} can be used to \type {\string}
%D the protected command, which by the way is seldom needed
%D in \CONTEXT.

\def\dosetunexpanded#1#2%
  {\@EA#1\@EA{\@EA#2\@EA}%
     \@EA{\@EA\donottest\csname\s!do\@EA\string\csname#2\endcsname\endcsname}%
   \@EA#1\@EA{\@EA\s!do\@EA\string\csname#2\endcsname}}

\def\docomunexpanded#1#2%
  {\@EA#1\@EA#2\@EA{\@EA\donottest\csname\s!do\string#2\endcsname}%
   \@EA#1\csname\s!do\string#2\endcsname}

\def\unexpanded#1%
  {\def\dounexpanded
     {\ifx\next\bgroup
        \@EA\dosetunexpanded
      \else
        \@EA\docomunexpanded
      \fi#1}%
   \futurelet\next\dounexpanded}

%%UNUSED
\def\honorunexpanded% for writing to a file or message
  {\def\donottest##1{\expandafter\gobblethreearguments\string##1}}

\def\forceunexpanded% for preventing expansion in \xdef
  {\def\donottest##1%
     {\expandafter\noexpand\csname\expandafter\gobblefourarguments\string##1\endcsname}}

\def\resetunexpanded%
  {\let\donottest\doprocesstest}


%D \macros
%D   {expandoneargafter,expandtwoargsafter}
%D
%D These two commands make macros more readable by hiding a
%D lot of \type {\expandafter}'s. They expand the arguments
%D after the first command.
%D
%D \starttyping
%D \expandoneargafter \command{\abc}
%D \expandtwoargsafter\command{\abc}{\def}
%D \stoptyping
%D
%D These commands expect the arguments to be macros.

\def\expandoneargafter   #1{\@EA#1\@EA}
\def\expandtwoargsafter#1#2{\@EA\@EA\@EA#1\@EA\@EA\@EA{\@EA#2\@EA}\@EA}


%D \macros
%D   {expandfirstafter,expandsecondafter,expandtwoafter}
%D
%D These three commands support expansion of arguments before
%D executing the commands that uses them. We can best
%D illustrate this with an example.
%D
%D \starttyping
%D \def\first  {alfa,beta,gamma}
%D \def\second {alfa,epsilon,zeta}
%D
%D \expandfirstafter  \doifcommon {\first} {alfa}    {\message{OK}}
%D \expandsecondafter \doifcommon {alfa}   {\second} {\message{OK}}
%D \expandtwoafter    \doifcommon {\first} {\second} {\message{OK}}
%D
%D \expandfirstafter\processcommalist[\first]\message
%D
%D \stoptyping
%D
%D The first three calls result in the threefold message
%D \type{OK}, the fourth one shows the three elements of
%D \type{\first}. The command \type{\ExpandFirstAfter} takes
%D care of (first) arguments that are delimited by \type{[ ]}.

\def\s!simpleexpandfirstafter#1%
  {\long\xdef\@@expanded{\noexpand\ExpandCommand{#1}}\@@expanded}

\def\s!complexexpandfirstafter[#1]%
  {\long\xdef\@@expanded{\noexpand\ExpandCommand[#1]}\@@expanded}

\def\expandfirstafter#1%
  {\let\ExpandCommand#1%
   \doifnextoptionalelse\s!complexexpandfirstafter\s!simpleexpandfirstafter}

\def\expandsecondafter#1#2#3%
  {\scratchtoks{#2}%
   \long\xdef\@@expanded{\noexpand#1{\the\scratchtoks}{#3}}\@@expanded}

\def\expandtwoafter#1#2#3%
  {\long\xdef\@@expanded{\noexpand#1{#2}{#3}}\@@expanded}

%D Now we can for instance define \type{\ifinstringelse} as:
%D \def\ifinstringelse
%D   {\expandtwoafter\p!doifinstringelse}


%D \macros
%D   {gobbleoneargument,gobble...arguments}
%D
%D The next set of macros just do nothing, except that they
%D get rid of a number of arguments.

\long\def\gobbleoneargument    #1{}
\long\def\gobbletwoarguments   #1#2{}
\long\def\gobblethreearguments #1#2#3{}
\long\def\gobblefourarguments  #1#2#3#4{}%%USED ONLY BY \forceunexpanded
%%UNUSED
\long\def\gobblefivearguments  #1#2#3#4#5{}
\long\def\gobblesixarguments   #1#2#3#4#5#6{}
\long\def\gobblesevenarguments #1#2#3#4#5#6#7{}
\long\def\gobbleeightarguments #1#2#3#4#5#6#7#8{}
\long\def\gobbleninearguments  #1#2#3#4#5#6#7#8#9{}
\long\def\gobbletenarguments   #1{\gobbleninearguments}

%>> Expansion & gobbles (end) ——————————————————————————————————————— >>
%<< —— Checking next character —————————————————————————————————————— >>

%D \macros
%D   {doifnextcharelse}

\long\def\doifnextcharelse#1#2#3% #1 should not be {} ! This version gobble spaces before
                                % char whereas \@ifnextchar from LaTeX does not. You
                                % CANNOT test for a space, see the \TeX book.
  {\let\charactertoken=#1% = needed here
   \def\!!stringa{#2}%
   \def\!!stringb{#3}%
   \futurelet\nexttoken\inspectnextcharacter}

\def\inspectnextcharacter
  {\ifx\nexttoken\blankspace
     \@EA\reinspectnextcharacter
   \else\ifx\nexttoken\charactertoken
     \@EAEAEA\!!stringa
   \else
     \@EAEAEA\!!stringb
   \fi\fi}

%D Because we will mostly use this macro for testing if the next
%D character is \type {[}, we also make a slightly faster variant
%D as it is not uncommon to have tens of thousands of calls to this
%D test in a run. Of course it also is more convenient to read a
%D trace then.

\let\nextoptionalcharactertoken=[

\long\def\doifnextoptionalelse#1#2%
  {\def\nextoptionalcommandyes{#1}%
   \def\nextoptionalcommandnop{#2}%
   \futurelet\nexttoken\inspectnextoptionalcharacter}

\def\inspectnextoptionalcharacter
  {\ifx\nexttoken\blankspace
     \@EA\reinspectnextoptionalcharacter
   \else\ifx\nexttoken\nextoptionalcharactertoken
     \@EAEAEA\nextoptionalcommandyes
   \else
     \@EAEAEA\nextoptionalcommandnop
   \fi\fi}

\let\nextbgroupcharactertoken\bgroup

\long\def\doifnextbgroupelse#1#2%
  {\def\nextbgroupcommandyes{#1}%
   \def\nextbgroupcommandnop{#2}%
   \futurelet\nexttoken\inspectnextbgroupcharacter}

\def\inspectnextbgroupcharacter
  {\ifx\nexttoken\blankspace
     \@EA\reinspectnextbgroupcharacter
   \else\ifx\nexttoken\nextbgroupcharactertoken
     \@EAEAEA\nextbgroupcommandyes
   \else
     \@EAEAEA\nextbgroupcommandnop
   \fi\fi}

%D This macro uses some auxiliary macros. Although we were able
%D to program quite complicated things, I only understood these
%D after rereading the \TEX book. The trick is in using a
%D command with a one character name. Such commands differ from
%D the longer ones in the fact that trailing spaces are {\em
%D not} skipped. This enables us to indirectly define a long
%D named macro that gobbles a space.
%D
%D In the first line we define \type{\blankspace}. Next we
%D make \type{\:} equivalent to \type{\reinspect...}. This
%D one||character command is expanded before the next
%D \type{\def} comes into action. This way the space after
%D \type{\:} becomes a delimiter of the longer named
%D \type{\reinspectnextcharacter}. The chain reaction is
%D visually compatible with the next sequence:
%D
%D \starttyping
%D \expandafter\def\reinspectnextcharacter %
%D   {\futurelet\nexttoken\inspectnextcharacter}
%D \stoptyping

\let\next\:

\def\:{\let\blankspace= }  \:

\def\:{\reinspectnextcharacter}
\expandafter\def\: {\futurelet\nexttoken\inspectnextcharacter}

\def\:{\reinspectnextoptionalcharacter}
\expandafter\def\: {\futurelet\nexttoken\inspectnextoptionalcharacter}

\def\:{\reinspectnextbgroupcharacter}
\expandafter\def\: {\futurelet\nexttoken\inspectnextbgroupcharacter}

\let\:\next

%>> Checking next character (end) ——————————————————————————————————— >>
%<< —— Variables (macros witout '\' or \csname ... \endcsname) —————— >>

%D \macros
%D   {setvalue,setgvalue,setevalue,setxvalue,
%D    letvalue,
%D    getvalue,
%D    resetvalue}
%D
%D \TEX's primitive \type{\csname} can be used to construct
%D all kind of commands that cannot be defined with
%D \type{\def} and \type{\let}. Every macro programmer sooner
%D or later wants macros like these.
%D
%D \starttyping
%D \setvalue   {name}{...} = \def\name{...}
%D \setgvalue  {name}{...} = \gdef\name{...}
%D \setevalue  {name}{...} = \edef\name{...}
%D \setxvalue  {name}{...} = \xdef\name{...}
%D \letvalue   {name}=\... = \let\name=\...
%D \letgvalue  {name}=\... = \global\let\name=\...
%D \getvalue   {name}      = \name
%D \resetvalue {name}      = \def\name{}
%D \stoptyping

\def\setvalue     #1{\expandafter \def\csname#1\endcsname}
\def\setgvalue    #1{\expandafter\gdef\csname#1\endcsname}
\def\setevalue    #1{\expandafter\edef\csname#1\endcsname}
\def\setxvalue    #1{\expandafter\xdef\csname#1\endcsname}
\def\getvalue     #1{\csname#1\endcsname}
\def\letvalue     #1{\expandafter\let\csname#1\endcsname}
\def\letgvalue    #1{\global\expandafter\let\csname#1\endcsname}
\def\resetvalue   #1{\expandafter\let\csname#1\endcsname\empty}
\def\ignorevalue#1#2{\expandafter\let\csname#1\endcsname\empty}


%D \macros
%D   {globallet,glet}

\def\globallet{\global\let}  \let\glet\globallet


%D \macros
%D   {showvalue,showargument}
%D
%D Two handy macros for testing purposes only:

\def\showvalue#1%
  {\expandafter\show\csname#1\endcsname}

\long\def\showargument#1%
  {\defconvertedargument\ascii{#1}\ascii}

%>> Variables (macros witout '\' or \csname ... \endcsname) (end) ——— >>
%<< —— Check ifdefined —————————————————————————————————————————————— >>

%D \macros
%D   {doifundefined,doifdefined,
%D    doifundefinedelse,doifdefinedelse,
%D    doifalldefinedelse}
%D
%D \starttyping
%D \doifundefined      {string}    {...}
%D \doifdefined        {string}    {...}
%D \doifundefinedelse  {string}    {then ...} {else ...}
%D \doifdefinedelse    {string}    {then ...} {else ...}
%D \stoptyping

\def\ifundefined#1%
  {\expandafter\ifx\csname#1\endcsname\relax}

\def\p!doifundefined#1%
  {\let\donottest\dontprocesstest
   \expandafter\ifx\csname#1\endcsname\relax}

\def\doifundefinedelse#1%
  {\p!doifundefined{#1}%
     \let\donottest\doprocesstest\@EA\firstoftwoarguments
   \else
     \let\donottest\doprocesstest\@EA\secondoftwoarguments
   \fi}

\def\doifdefinedelse#1%
  {\p!doifundefined{#1}%
     \let\donottest\doprocesstest\@EA\secondoftwoarguments
   \else
     \let\donottest\doprocesstest\@EA\firstoftwoarguments
   \fi}

\def\doifundefined#1%
  {\p!doifundefined{#1}%
     \let\donottest\doprocesstest\@EA\firstofoneargument
   \else
     \let\donottest\doprocesstest\@EA\gobbleoneargument
   \fi}

\def\doifdefined#1%
  {\p!doifundefined{#1}%
     \let\donottest\doprocesstest\@EA\gobbleoneargument
   \else
     \let\donottest\doprocesstest\@EA\firstofoneargument
   \fi}


%D \macros
%D   {letbeundefined}
%D
%D Testing for being undefined comes down to testing on \type
%D {\relax} when we use \type {\csname}, but when using \type
%D {\ifx}, we test on being \type {\undefined}! In \ETEX\ we
%D have \type {\ifcsname} and that way of testing on existance
%D is not the same as the one described here. Therefore we
%D introduce:

\def\letbeundefined#1%
  {\expandafter\let\csname#1\endcsname\relax}

%>> Check ifdefined (end) ——————————————————————————————————————————— >>
%<< —— doifs ———————————————————————————————————————————————————————— >>

%D \macros
%D   {doif,doifelse,doifnot,
%D    donottest}
%D
%D \starttyping
%D \doif     {string1} {string2} {...}
%D \doifnot  {string1} {string2} {...}
%D \doifelse {string1} {string2} {then ...}{else ...}
%D \stoptyping
%D
%D When expansion gives problems, we can precede the
%D troublemaker with \type{\donottest}.

\long\def\doif#1#2%
  {\let\donottest\dontprocesstest
   \edef\!!stringa{#1}%
   \edef\!!stringb{#2}%
   \let\donottest\doprocesstest
   \ifx\!!stringa\!!stringb
     \expandafter\firstofoneargument
   \else
     \expandafter\gobbleoneargument
   \fi}

\long\def\doifnot#1#2%
  {\let\donottest\dontprocesstest
   \edef\!!stringa{#1}%
   \edef\!!stringb{#2}%
   \let\donottest\doprocesstest
   \ifx\!!stringa\!!stringb
     \expandafter\gobbleoneargument
   \else
     \expandafter\firstofoneargument
   \fi}


\long\def\doifelse#1#2%
  {\let\donottest\dontprocesstest
   \edef\!!stringa{#1}%
   \edef\!!stringb{#2}%
   \let\donottest\doprocesstest
   \ifx\!!stringa\!!stringb
     \expandafter\firstoftwoarguments
   \else
     \expandafter\secondoftwoarguments
   \fi}


%D \macros
%D   {doifempty,doifemptyelse,doifnotempty}
%D
%D We complete our set of conditionals with:
%D
%D \starttyping
%D \doifempty     {string} {...}
%D \doifnotempty  {string} {...}
%D \doifemptyelse {string} {then ...} {else ...}
%D \stoptyping
%D
%D This time, the string is not expanded.

\long\def\doifemptyelse#1%
  {\def\!!stringa{#1}%
   \ifx\!!stringa\empty
     \expandafter\firstoftwoarguments
   \else
     \expandafter\secondoftwoarguments
   \fi}

\long\def\doifempty#1%
  {\def\!!stringa{#1}%
   \ifx\!!stringa\empty
     \expandafter\firstofoneargument
   \else
     \expandafter\gobbleoneargument
   \fi}

\long\def\doifnotempty#1%
  {\def\!!stringa{#1}%
   \ifx\!!stringa\empty
     \expandafter\gobbleoneargument
   \else
     \expandafter\firstofoneargument
   \fi}


%D \macros
%D   {doifinset,doifnotinset,doifinsetelse}
%D
%D \starttyping
%D \doifinset     {string} {string,...} {...}
%D \doifnotinset  {string} {string,...} {...}
%D \doifinsetelse {string} {string,...} {then ...} {else ...}
%D \stoptyping

\def\p!docheckiteminset#1%
  {\edef\!!stringb{#1}%
   \ifx\!!stringa\!!stringb
     \donetrue
     \expandafter\quitcommalist
   \fi}

\def\p!doifinsetelse#1#2#3#4%
  {\let\donottest\dontprocesstest
   \donefalse
   \edef\!!stringa{#3}%
   \ifx\!!stringa\empty
   \else
     \processcommalist[#4]\p!docheckiteminset
   \fi
   \let\donottest\doprocesstest
   \ifdone\expandafter#1\else\expandafter#2\fi}

\long\def\doifinsetelse
  {\p!doifinsetelse\firstoftwoarguments\secondoftwoarguments}

\long\def\doifinset
  {\p!doifinsetelse\firstofoneargument\gobbleoneargument}

\long\def\doifnotinset
  {\p!doifinsetelse\gobbleoneargument\firstofoneargument}


%D \macros
%D   {doifcommon,doifnotcommon,doifcommonelse}
%D
%D Probably the most time consuming tests are those that test
%D for overlap in sets of strings.
%D
%D \starttyping
%D \doifcommon     {string,...} {string,...} {...}
%D \doifnotcommon  {string,...} {string,...} {...}
%D \doifcommonelse {string,...} {string,...} {then ...} {else ...}
%D \stoptyping

\def\p!dodocommoncheck#1%
  {\edef\!!stringb{#1}%
   \ifx\!!stringa\!!stringb
     \donetrue
     \expandafter\quitprevcommalist
   \fi}

\def\p!doifcommonelse#1#2#3#4%
  {\donefalse
   \let\donottest\dontprocesstest
   \def\p!docommoncheck##1%
     {\edef\!!stringa{##1}%
      \def\commalistelement{##1}% no let to stringa
      \processcommalist[#4]\p!dodocommoncheck}%
   \processcommalist[#3]\p!docommoncheck
   \let\donottest\doprocesstest
   \ifdone\expandafter#1\else\expandafter#2\fi}

\def\doifcommonelse
  {\p!doifcommonelse\firstoftwoarguments\secondoftwoarguments}

\def\doifcommon
  {\p!doifcommonelse\firstofoneargument \gobbleoneargument}

\def\doifnotcommon
  {\p!doifcommonelse\gobbleoneargument  \firstofoneargument}


%D \macros
%D   {doifinstringelse, doifincsnameelse}
%D
%D We can check for the presence of a substring in a given
%D sequence of characters.
%D
%D \starttyping
%D \doifinstringelse {substring} {string} {then ...} {else ...}
%D \stoptyping
%D

\long\def\doifinstringelse#1%
  {\edef\@@@instring{#1}% expand #1 here
   \ifx\@@@instring\empty
     \@EA\thirdofthreearguments
   \else
     \@EA\dodoifinstringelse
   \fi}

\long\def\dodoifinstringelse#1%
  {\p!doifinstringelse\@@@instring{#1}%
     \@EA\firstoftwoarguments
   \else
     \@EA\secondoftwoarguments
   \fi}

%%UNUSED
% \def\pp!doifstringinstringelse#1%
%   {\if#1@%
%      \@EA\secondoftwoarguments
%    \else
%      \@EA\firstoftwoarguments
%    \fi}

% \long\def\doifstringinstringelse#1#2%
%   {\long\@EA\def\@EA\p!doifstringinstringelse\@EA##\@EA1#1##2##3\war
%      {\pp!doifstringinstringelse##2}%
%    \@EA\@EA\@EA\p!doifstringinstringelse\@EA#2#1@@\war}

\long\def\doifinstring#1%%
  {\edef\@@@instring{#1}% expand #1 here
   \ifx\@@@instring\empty
     \@EA\gobbletwoarguments
   \else
     \@EA\dodoifinstring
   \fi}

\long\def\dodoifinstring#1%
  {\p!doifinstringelse\@@@instring{#1}%
     \@EA\firstofoneargument
   \else
     \@EA\gobbleoneargument
   \fi}

\long\def\doifnotinstring#1%%
  {\edef\@@@instring{#1}% expand #1 here
   \ifx\@@@instring\empty
     \@EA\gobbletwoarguments
   \else
     \@EA\dodoifnotinstring
   \fi}

\long\def\dodoifnotinstring#1%
  {\p!doifinstringelse\@@@instring{#1}%
     \@EA\gobbleoneargument
   \else
     \@EA\firstofoneargument
   \fi}

\long\def\p!doifinstringelse#1#2% ##2 can be {abc}
  {\long\@EA\def\@EA\pp!doifinstringelse\@EA##\@EA1#1##2##3\war % expand #1 here
     {\csname if\if##2@fals\else tru\fi e\endcsname}%
   \expanded{\pp!doifinstringelse#2#1}@@\war} % expand #2 here

\long\def\p!doifincsnameelse#1#2%
  {\long\def\pp!doifincsnameelse##1#1##2##3\war
     {\csname if\if##2@fals\else tru\fi e\endcsname}%
   \@EA\pp!doifincsnameelse#2#1@@\war}

\long\def\doifincsnameelse#1#2%                   % #3#4%
  {\edef\@@@instring{#1}%
   \@EA\p!doifincsnameelse\@EA{\@@@instring}{#2}% % #3\else#4\fi}
     \expandafter\firstoftwoarguments
   \else
     \expandafter\secondoftwoarguments
   \fi}


%%PROBABLY UNUSED
%D \macros
%D   {doifsamestringselse,doifsamestring,doifnotsamestring}
%D
%D The next comparison macro converts the arguments into their meaning
%D expanded strings. This command can be used to compare for
%D instance \type {\jobname} with a name stored in a macro.

\def\@@doifsamestringelse#1#2%
  {\edef\!!stringa{#1}%
   \edef\!!stringb{#2}%
   \convertcommand\!!stringa\to\!!stringa
   \convertcommand\!!stringb\to\!!stringb
   \ifx\!!stringa\!!stringb}

\def\doifsamestringelse#1#2%
  {\@@doifsamestringelse{#1}{#2}%
     \expandafter\firstoftwoarguments
   \else
     \expandafter\secondoftwoarguments
   \fi}

\def\doifsamestring#1#2%
  {\@@doifsamestringelse{#1}{#2}%
     \expandafter\firstofoneargument
   \else
     \expandafter\gobbleoneargument
   \fi}

\def\doifnotsamestring#1#2%
  {\@@doifsamestringelse{#1}{#2}%
     \expandafter\gobbleoneargument
   \else
     \expandafter\firstofoneargument
   \fi}


%D \macros
%D   {doifnumberelse}
%D
%D \starttyping
%D \doifnumberelse {string} {then ...} {else ...}
%D \stoptyping
%D
%D The macro accepts \type{123}, \type{abc}, \type{{}},
%D \type{\getal} and \type{\the\count...}. This macro is a
%D rather dirty one.

\long\def\doifnumberelse#1% does not accept counters
  {\ifcase0\ifcase1#1\or\or\or\or\or\or\or\or\or\else1\fi\space
     \expandafter\secondoftwoarguments
   \else
     \expandafter\firstoftwoarguments
   \fi}


%D \macros
%D   {doifvalue,doifnotvalue,doifelsevalue,
%D    doifnothing,doifsomething,doifelsenothing,
%D    doifvaluenothing,doifvaluesomething,doifelsevaluenothing}
%D
%D These long named \type{\if} commands can be used to access
%D macros (or variables) that are normally accessed by using
%D \type{\getvalue}. Using these alternatives saves us three
%D tokens per call. Anyone familiar with the not||values
%D ones, can derive their meaning from the definitions.
%D Only the fastest version follow.

\long\def\doifvalue#1#2%
  {\edef\!!stringa{\csname#1\endcsname}\edef\!!stringb{#2}%
   \ifx\!!stringa\!!stringb
     \expandafter\firstofoneargument
   \else
     \expandafter\gobbleoneargument
   \fi}

\long\def\doifnotvalue#1#2%
  {\edef\!!stringa{\csname#1\endcsname}\edef\!!stringb{#2}%
   \ifx\!!stringa\!!stringb
     \expandafter\gobbleoneargument
   \else
     \expandafter\firstofoneargument
   \fi}

\long\def\doifelsevalue#1#2%
  {\edef\!!stringa{\csname#1\endcsname}\edef\!!stringb{#2}%
   \ifx\!!stringa\!!stringb
     \expandafter\firstoftwoarguments
   \else
     \expandafter\secondoftwoarguments
   \fi}

\long\def\doifnothing#1%
  {\edef\!!stringa{#1}%
   \ifx\!!stringa\empty
     \expandafter\firstofoneargument
   \else
     \expandafter\gobbleoneargument
   \fi}

\long\def\doifsomething#1%
  {\edef\!!stringa{#1}%
   \ifx\!!stringa\empty
     \expandafter\gobbleoneargument
   \else
     \expandafter\firstofoneargument
   \fi}

\long\def\doifelsenothing#1%
  {\edef\!!stringa{#1}%
   \ifx\!!stringa\empty
     \expandafter\firstoftwoarguments
   \else
     \expandafter\secondoftwoarguments
   \fi}

\long\def\doifsomethingelse#1%
  {\edef\!!stringa{#1}%
   \ifx\!!stringa\empty
     \expandafter\secondoftwoarguments
   \else
     \expandafter\firstoftwoarguments
   \fi}

\long\def\doifvaluenothing#1%
  {\edef\!!stringa{\csname#1\endcsname}%
   \ifx\!!stringa\empty
     \expandafter\firstofoneargument
   \else
     \expandafter\gobbleoneargument
   \fi}

\long\def\doifvaluesomething#1%
  {\edef\!!stringa{\csname#1\endcsname}%
   \ifx\!!stringa\empty
     \expandafter\gobbleoneargument
   \else
     \expandafter\firstofoneargument
   \fi}

\long\def\doifelsevaluenothing#1%
  {\edef\!!stringa{\csname#1\endcsname}%
   \ifx\!!stringa\empty
     \expandafter\firstoftwoarguments
   \else
     \expandafter\secondoftwoarguments
   \fi}


%D \macros
%D   {doifemptyelsevalue, doifemptyvalue, doifnotemptyvalue}
%D
%D Also handy:

\def\doifemptyelsevalue#1%
  {\@EA\ifx\csname#1\endcsname\empty
     \expandafter\firstoftwoarguments
   \else
     \expandafter\secondoftwoarguments
   \fi}

\def\doifemptyvalue#1%
  {\@EA\ifx\csname#1\endcsname\empty
     \expandafter\firstofoneargument
   \else
     \expandafter\gobbleoneargument
   \fi}

\def\doifnotemptyvalue#1%
  {\@EA\ifx\csname#1\endcsname\empty
     \expandafter\gobbleoneargument
   \else
     \expandafter\firstofoneargument
   \fi}


%D \macros
%D   {doifallcommonelse}
%D
%D A complete match of two sets can be tested with
%D \type {\doifallcommonelse}, where the first two
%D arguments are sets.

\def\@@doifallcommonelse#1#2#3#4% slow
  {\def\p!docommoncheck##1%
     {\doifnotinset{##1}{#4}\donefalse
      \ifdone\else\expandafter\quitcommalist\fi}%
   \donetrue
   \processcommalist[#3]\p!docommoncheck
   \ifdone\expandafter#1\else\expandafter#2\fi}

\def\doifallcommonelse
  {\@@doifallcommonelse\firstoftwoarguments\secondoftwoarguments}

\def\doifallcommon
  {\@@doifallcommonelse\firstofonearguments\gobbleoneargument}

\def\doifnotallcommon
  {\@@doifallcommonelse\gobbleoneargument\firstofonearguments}

%>> doifs (end) ————————————————————————————————————————————————————— >>
%<< —— Process comma separated lists ———————————————————————————————— >>

%D \macros
%D   {processcommalist,processcommacommand,quitcommalist,
%D    processcommalistwithparameters}
%D
%D We've already seen some macros that take care of comma
%D separated lists. Such list can be processed with
%D
%D \starttyping
%D \processcommalist[string,string,...]\commando
%D \stoptyping
%D
%D The user supplied command \type{\commando} receives one
%D argument: the string. This command permits nesting and
%D spaces AFTER COMMAS are skipped. Empty sets are no problem.
%D
%D \startbuffer
%D \def\dosomething#1{(#1)}
%D
%D 1: \processcommalist [\hbox{$a,b,c,d,e,f$}] \dosomething \par
%D 2: \processcommalist [{a,b,c,d,e,f}]        \dosomething \par
%D 3: \processcommalist [{a,b,c},d,e,f]        \dosomething \par
%D 4: \processcommalist [a,b,{c,d,e},f]        \dosomething \par
%D 5: \processcommalist [a{b,c},d,e,f]         \dosomething \par
%D 6: \processcommalist [{a,b}c,d,e,f]         \dosomething \par
%D 7: \processcommalist []                     \dosomething \par
%D 8: \processcommalist [{[}]                  \dosomething \par
%D \stopbuffer
%D
%D \typebuffer
%D
%D Before we show the result, we present the macro's:

\newcount\commalevel

\def\dododoprocesscommaitem
  {\csname\s!next\the\commalevel\endcsname}

\def\dodoprocesscommaitem
  {\ifx\nexttoken\blankspace
     \@EA\redoprocesscommaitem
   \else\ifx\nexttoken]%
     \@EAEAEA\gobbleoneargument% ]
   \else
     \@EAEAEA\dododoprocesscommaitem
   \fi\fi}

\def\doprocesscommaitem
  {\futurelet\nexttoken\dodoprocesscommaitem}

%D Empty arguments are not processed. Empty items (\type{,,})
%D however are treated. We have to check for the special case
%D \type{[{a,b,c}]}.

\def\processcommalist[%
  {\futurelet\nexttoken\docheckcommaitem}

\def\docheckcommaitem
  {\ifx\nexttoken]%
     \expandafter\gobblethreearguments% \relax (see below), ], and \commando
   \else
     \expandafter\doprocesscommalist
   \fi
   \relax} % this one preserves the next {}

\def\doprocesscommalist#1]#2%
  {\global\advance\commalevel \plusone
   \long\expandafter\def\csname\s!next\the\commalevel\endcsname##1,%
     {#2{##1}\doprocesscommaitem}%
   \@EA\dodoprocesscommaitem\gobbleoneargument#1,]\relax% \relax (see above)
   \global\advance\commalevel \minusone }

%D One way of quitting a commalist halfway is:

\def\quitcommalist
  {\begingroup\let\doprocesscommaitem\doquitcommalist}

\def\doquitcommalist#1]%
  {\endgroup}

\def\quitprevcommalist
  {\begingroup\let\doprocesscommaitem\doquitprevcommalist}

\def\doquitprevcommalist#1]%
  {\let\doprocesscommaitem\doquitcommalist}

%D The hack we used for checking the next character
%D \type {\doifnextcharelse} is also used here.

\def\:{\redoprocesscommaitem}

\expandafter\def\: {\futurelet\nexttoken\dodoprocesscommaitem}

%D \starttyping
%D \def\first{aap,noot,mies}
%D \def\second{laatste}
%D
%D \processcommacommand[\first]\message
%D \processcommacommand[\first,second,third]\message
%D \processcommacommand[\first,between,\second]\message
%D \stoptyping
%D
%D Commands that are part of the list are expanded, so the
%D use of this macro has its limits.

\def\processcommacommand[#1]%
  {\expanded{\processcommalist[#1]}}

%D The argument to \type{\command} is not delimited. Because
%D we often use \type{[]} as delimiters, we also have:
%D
%D \starttyping
%D \processcommalistwithparameters[string,string,...]\command
%D \stoptyping
%D
%D where \type{\command} looks like:
%D
%D \starttyping
%D \def\command[#1]{... #1 ...}
%D \stoptyping

\def\processcommalistwithparameters[#1]#2%
  {\def\docommand##1{#2[##1]}%
   \processcommalist[#1]\docommand}


%D \macros
%D   {processseparatedlist}
%D
%D Maybe a bit late, but here is a more general version of the
%D \type{\processcommalist} command. This time we don't handle
%D nesting but accept arbitrary seperators.
%D
%D \starttyping
%D \processseparatedlist[list][separator]\command
%D \stoptyping
%D
%D One can think of things like:
%D
%D \starttyping
%D \processseparatedlist[alfa+beta+gamma][+]\message
%D \stoptyping

\def\doprocessseparatedlist#1]#2[#3]#4%
   {\def\dodoprocessseparatedlist##1##2#3%
      {\def\!!stringa{##2}% suggested by VZ
       \if]##1%
         \let\dodoprocessseparatedlist\relax
       \else\ifx\blankspace\!!stringa
         #4{##1}%
       \else\if]##2%
         \let\dodoprocessseparatedlist\relax
       \else
         #4{##1##2}%
       \fi\fi\fi
       \dodoprocessseparatedlist}%
    \@EA\dodoprocessseparatedlist\gobbleoneargument#1#3]#3}

\def\processseparatedlist[%
  {\doprocessseparatedlist\relax}


%%PROBABLY UNUSED
%D \macros
%D   {processlist}
%D
%D An even more general list processing macro is the
%D following one:
%D
%D \starttyping
%D \processlist{beginsym}{endsym}{separator}\docommand list
%D \stoptyping
%D
%D This one supports arbitrary open and close symbols as well
%D as user defined separators.
%D
%D \starttyping
%D \processlist(){=>}\docommand(a=>b=>c=>d)
%D \stoptyping

\long\def\processlist#1#2#3#4% no blank skipping !
  {\def\doprocesslist##1#2%
     {\def\dodoprocesslist####1####2#3%
        {\ifx#2####1%
           \let\dodoprocesslist\relax
         \else\ifx#2####2%
           \let\dodoprocesslist\relax
         \else
           #4{####1####2}%
         \fi\fi
         \dodoprocesslist}%
      \expandafter\dodoprocesslist\gobbleoneargument##1#3#2#3}%
   \def\dodoprocesslist#1%
     {\doprocesslist\relax}%
   \dodoprocesslist}

%>> Process comma separated lists (end) ————————————————————————————— >>
%<< —— Assignments —————————————————————————————————————————————————— >>

%D \macros
%D   {dosetvalue,dosetevalue,dosetgvalue,docopyvalue,doresetvalue,
%D    dogetvalue}
%D
%D \starttyping
%D \dosetvalue   {label}    {variable}   {value}
%D \dosetevalue  {label}    {variable}   {value}
%D \dosetgvalue  {label}    {variable}   {value}
%D \docopyvalue  {to label} {from label} {variable}
%D \doresetvalue {label}    {variable}
%D \stoptyping
%D
%D These macros are in fact auxiliary ones and are not meant
%D for use outside the assignment macros.

\def\dosetvalue#1#2% #3
  {\@EA\def\csname#1#2\endcsname} % {#3}}

\def\dosetevalue#1#2% #3
  {\@EA\edef\csname#1#2\endcsname} % {#3}}

\def\dosetgvalue#1#2% #3
  {\@EA\gdef\csname#1#2\endcsname} % {#3}}

\def\doresetvalue#1#2%
  {\@EA\let\csname#1#2\endcsname\empty}

\def\doignorevalue#1#2#3%
  {\@EA\let\csname#1#2\endcsname\empty}

\def\docopyvalue#1#2#3%
  {\@EA\def\csname#1#3\endcsname{\csname#2#3\endcsname}}


%D \macros
%D   {doassign,undoassign,doassignempty}
%D
%D Assignments are the backbone of \CONTEXT. Abhorred by the
%D concept of style file hacking, we took a considerable effort
%D in building a parameterized system. Unfortunately there is a
%D price to pay in terms of speed. Compared to other packages
%D and taking the functionality of \CONTEXT\ into account, the
%D total size of the format file is still very acceptable. Now
%D how are these assignments done.
%D
%D Assignments can be realized with:
%D
%D \starttyping
%D \doassign[label][variable=value]
%D \undoassign[label][variable=value]
%D \stoptyping
%D
%D and:
%D
%D \starttyping
%D \doassignempty[label][variable=value]
%D \stoptyping
%D
%D Assignments like \type{\doassign} are compatible with:
%D
%D \starttyping
%D \def\labelvariable{value}
%D \stoptyping
%D
%D We do check for the presence of an \type{=} and loudly
%D complain of it's missed. We will redefine this macro later
%D on, when a more advanced message mechanism is implemented.

%%MAYBE WE CAN REMOVE IT
\newif\iferrorisfatal

\def\waitonfatalerror
  {\iferrorisfatal\wait\fi}

\def\showassignerror#1#2%
  {\writestatus{setup}{missing or ungrouped '=' after '#1' in line #2}%
   \waitonfatalerror}

\let\currentvalue\empty

\def\p!n!doassign#1#2\@relax@#3=#4=#5#6\@relax@
  {\ifx\empty#3\empty
     \@EA\xshowassignerror
   \else\ifx#5\empty
     \@EAEAEA\xshowassignerror
   \else
     \@EAEAEA#1%
   \fi\fi
   {#2}{#3}{#4}}

\def\p!e!doassign#1#2\@relax@#3=#4=#5#6\@relax@
  {\ifx\empty#3\empty
     \@EA\xshowassignerror
   \else\ifx#5\empty
     \@EAEAEA\xshowassignerror
   \else
     \@EA\ifx\csname#2#3\endcsname\relax
       \let\currentvalue\empty
     \else
       \@EA\let\@EA\currentvalue\csname#2#3\endcsname
     \fi
     \@EAEAEA#1%
   \fi\fi
   {#2}{#3}{#4}}

\let\p!doassign\p!n!doassign

\let\currentvalue\empty

\def\xshowassignerror#1#2#3%
  {\showassignerror{#2}{\the\inputlineno\space(#1)}}

\def\doassign  [#1][#2]{\p!doassign\dosetvalue  #1\@relax@#2==\empty\@relax@}
\def\doeassign [#1][#2]{\p!doassign\dosetevalue #1\@relax@#2==\empty\@relax@}
\def\undoassign[#1][#2]{\p!doassign\doresetvalue#1\@relax@#2==\empty\@relax@}

\def\doassignempty[#1][#2=#3]%
  {\ifundefined{#1#2}\dosetvalue{#1}{#2}{#3}\fi}


%D \macros
%D   {assignifempty}
%D
%D We can assign a default value to an empty macro using:
%D
%D \starttyping
%D \assignifempty \macros {default value}
%D \stoptyping
%D
%D We don't explicitly test if the macro is defined.

\def\assignifempty#1#2% can be sped up
  {\doifsomething{#1}{\def#1{#2}}} % {\doifnot{#1}{}{\def#1{#2}}}


%D \macros
%D   {doifassignmentelse}
%D
%D A lot of \CONTEXT\ commands take optional arguments, for
%D instance:
%D
%D \starttyping
%D \dothisorthat[alfa,beta]
%D \dothisorthat[first=foo,second=bar]
%D \dothisorthat[alfa,beta][first=foo,second=bar]
%D \stoptyping
%D
%D Although a combined solution is possible, we prefer a
%D seperation. The next command takes care of propper
%D handling of such multi||faced commands.
%D
%D \starttyping
%D \doifassignmentelse {...} {then ...} {else ...}
%D \stoptyping

\def\doifassignmentelse#1%
  {\convertargument#1\to\ascii
   \doifinstringelse=\ascii}

%>> Assignments (end) ——————————————————————————————————————————————— >>
%<< —— Parameters ——————————————————————————————————————————————————— >>

%D \macros
%D   {copyparameters}
%D
%D \starttyping
%D \copyparameters
%D   [internal][external]
%D   [alfa,beta]
%D \stoptyping
%D
%D \starttyping
%D \def\internalalfa {\externalalfa}
%D \def\internalbeta {\externalbeta}
%D \stoptyping

\def\copyparameters[#1]#2[#3]#4[#5]%
  {\doifnot{#1}{#3}
     {\def\docopyparameter{\docopyvalue{#1}{#3}}%
      \processcommalist[#5]\docopyparameter}}

%>> Parameters (end) ———————————————————————————————————————————————— >>
%<< —— Arguments handling ——————————————————————————————————————————— >>

%D \macros
%D   {dosingleargument,dodoubleargument,dotripleargument}
%D
%D When working with delimited arguments, spaces and
%D lineendings can interfere. The next set of macros uses
%D \TEX' internal scanner for grabbing everything between
%D arguments. Forgive me the funny names.

\def\dosingleargument    {\chardef\expectedarguments 1 \getsingleempty[]}
\def\dodoubleargument    {\chardef\expectedarguments 2 \getdoubleempty[]}
\def\dotripleargument    {\chardef\expectedarguments 3 \gettripleempty[]}

\long\def\dogetargument#1#2#3#4%
  {\let\charactertoken=#1%
   \def\!!stringa{\noshowargumenterror#3\dodogetargument}%
   \def\!!stringb{\doshowargumenterror#4\dodogetargument#1#2}%
   \futurelet\nexttoken\inspectnextcharacter}

\def\getsingleempty#1#2#3%
  {\def\dodogetargument%
     {#3}%
   \dogetargument#1#2\firstargumenttrue\firstargumentfalse}

\def\getdoubleempty#1#2#3%
  {\def\dodogetargument#1##1#2%
     {\def\dodogetargument%
        {#3#1{##1}#2}%
      \dogetargument#1#2\secondargumenttrue\secondargumentfalse}%
   \dogetargument#1#2\firstargumenttrue\firstargumentfalse}

\def\gettripleempty#1#2#3%
  {\def\dodogetargument#1##1#2%
     {\def\dodogetargument#1####1#2%
        {\def\dodogetargument%
           {#3#1{##1}#2%
              #1{####1}#2}%
         \dogetargument#1#2\thirdargumenttrue\thirdargumentfalse}%
      \dogetargument#1#2\secondargumenttrue\secondargumentfalse}%
   \dogetargument#1#2\firstargumenttrue\firstargumentfalse}


%D \macros
%D   {iffirstagument,ifsecondargument,ifthirdargument}
%D
%D We use some signals for telling the calling macros if all
%D wanted arguments are indeed supplied by the user.

\newif\iffirstargument
\newif\ifsecondargument
\newif\ifthirdargument


%D \macros
%D   {dosingleempty,dodoubleempty,dotripleempty}
%D
%D The empty argument supplying macros mentioned before, look
%D like:
%D
%D \starttyping
%D \dosingleempty    \command
%D \dodoubleempty    \command
%D \dotripleempty    \command
%D \stoptyping
%D
%D So \type{\dodoubleempty} leades to:
%D
%D \starttyping
%D \command[#1][#2]
%D \command[#1][]
%D \command[][]
%D \stoptyping
%D
%D Depending of the generousity of the user. Afterwards one can
%D use the \type{\if...argument} boolean.

\chardef\noexpectedarguments=0
\chardef\expectedarguments  =0

\def\showargumenterror#1#2%
  {\writestatus{systems}{#1 argument(s) expected in line #2}}

\def\doshowargumenterror
  {\ifnum\expectedarguments>\noexpectedarguments
     \showargumenterror{\number\expectedarguments}{\number\inputlineno}%
   \fi
   \noshowargumenterror}

\def\noshowargumenterror
  {\let\expectedarguments\noexpectedarguments}

\def\dosingleempty#1%
  {\noshowargumenterror % \relax % prevents lookahead, brr
   \doifnextoptionalelse
     {\firstargumenttrue#1}
     {\dosinglefakeempty#1}}

\def\dodoubleempty#1%
  {\noshowargumenterror % \relax % prevents lookahead, brr
   \doifnextoptionalelse
     {\dodoubletestempty#1}
     {\dodoublefakeempty#1}}

\def\dotripleempty#1%
  {\noshowargumenterror % \relax % prevents lookahead, brr
   \doifnextoptionalelse
     {\dotripletestempty#1}
     {\dotriplefakeempty#1}}

\def\dosinglefakeempty#1%
  {\firstargumentfalse#1[]}

\def\dodoublefakeempty#1%
  {\firstargumentfalse\secondargumentfalse#1[][]}

\def\dotriplefakeempty#1%
  {\firstargumentfalse\secondargumentfalse\thirdargumentfalse#1[][][]}

\long\def\dodoubletestempty#1[#2]%
  {\firstargumenttrue
   \doifnextoptionalelse
     {\secondargumenttrue #1[{#2}]}
     {\secondargumentfalse#1[{#2}][]}}

\long\def\dotripletestempty#1[#2]%
  {\firstargumenttrue
   \doifnextoptionalelse
     {\dotripletestemptyx #1[{#2}]}
     {\secondargumentfalse
      \thirdargumentfalse #1[{#2}][][]}}

\long\def\dotripletestemptyx#1[#2][#3]%
  {\secondargumenttrue
   \doifnextoptionalelse
     {\thirdargumenttrue #1[{#2}][{#3}]}
     {\thirdargumentfalse#1[{#2}][{#3}][]}}


%D \macros
%D   {firstofoneargument, firstoftwoarguments, firstofthreearguments
%D    secondoftwoarguments, secondofthreearguments,
%D    thirdofthreearguments}
%D
%D The next six macros (dedicated to Taco) can conveniently be
%D used to select arguments. Their names explain their
%D functionality.

\long\def\firstofoneargument#1{#1}

\long\def\firstoftwoarguments #1#2{#1}
\long\def\secondoftwoarguments#1#2{#2}

\long\def\firstofthreearguments #1#2#3{#1}
\long\def\secondofthreearguments#1#2#3{#2}
\long\def\thirdofthreearguments #1#2#3{#3}

\long\def\firstoffourarguments #1#2#3#4{#1}
\long\def\secondoffourarguments#1#2#3#4{#2}
\long\def\thirdoffourarguments #1#2#3#4{#3}
\long\def\fourthoffourarguments#1#2#3#4{#4}

%%PROBABLY UNUSED
% \long\def\firstoffivearguments #1#2#3#4#5{#1}
% \long\def\secondoffivearguments#1#2#3#4#5{#2}
% \long\def\thirdoffivearguments #1#2#3#4#5{#3}
% \long\def\fourthoffivearguments#1#2#3#4#5{#4}
% \long\def\fifthoffivearguments #1#2#3#4#5{#5}

% \long\def\firstofsixarguments #1#2#3#4#5#6{#1}
% \long\def\secondofsixarguments#1#2#3#4#5#6{#2}
% \long\def\thirdofsixarguments #1#2#3#4#5#6{#3}
% \long\def\fourthofsixarguments#1#2#3#4#5#6{#4}
% \long\def\fifthofsixarguments #1#2#3#4#5#6{#5}
% \long\def\sixthofsixarguments #1#2#3#4#5#6{#6}


%D \macros
%D   {dowithpargument,dowithwargument}
%D
%D We start with a commands that acts on paragraphs. This
%D command is called as:
%D
%D \starttyping
%D \dowithpargument\command
%D \dowithpargument{\command ... }
%D \stoptyping
%D
%D \starttyping
%D \command{...}
%D \command ... \par
%D \command
%D   {...}
%D \command
%D   ... \par
%D \stoptyping

\def\dowithpargument#1%
  {\def\nextpar##1 \par{#1{##1}}%
   \def\nextarg##1{#1{##1}}%
   \doifnextbgroupelse\nextarg{\doifnextcharelse\par{#1{}}\nextpar}}

%D The \type{p} in the previous command stands for paragraph.
%D When we want to act upon words we can use the \type{w}
%D alternative.
%D
%D \starttyping
%D \dowithwargument\command
%D \dowithwargument{... \command ...}
%D \stoptyping
%D
%D The main difference bwteen two alternatives is in the
%D handling of \type{\par}'s. This time the space token acts
%D as a delimiter.
%D
%D \starttyping
%D \command{...}
%D \command ...
%D \command
%D   {...}
%D \command
%D   ...
%D \stoptyping

\def\dowithwargument#1%
  {\def\nextwar##1 {#1{##1}}%
   \def\nextarg##1{#1{##1}}%
   \doifnextbgroupelse\nextarg\nextwar}


%D \macros
%D   {dosingleargumentwithset,
%D    dodoubleargumentwithset,dodoubleemptywithset,
%D    dotripleargumentwithset,dotripleemptywithset}
%D
%D These maybe too mysterious macros enable us to handle more
%D than one setup at once.
%D
%D \starttyping
%D \dosingleargumentwithset \command[#1]
%D \dodoubleargumentwithset \command[#1][#2]
%D \dotripleargumentwithset \command[#1][#2][#3]
%D \dodoubleemptywithset    \command[#1][#2]
%D \dotripleemptywithset    \command[#1][#2][#3]
%D \stoptyping
%D
%D The first macro calls \type{\command[##1]} for each string
%D in the set~\type{#1}. The second one calls for
%D \type{\commando[##1][#2]} and the third, well one may guess.
%D These commands support constructions like:
%D
%D \starttyping
%D \def\dodefinesomething[#1][#2]%
%D   {\getparameters[#1][#2]}
%D
%D \def\definesomething%
%D   {\dodoubleargumentwithset\dodefinesomething}
%D \stoptyping
%D
%D Which accepts calls like:
%D
%D \starttyping
%D \definesomething[alfa,beta,...][variable=...,...]
%D \stoptyping
%D
%D Now a whole bunch of variables like \type{\alfavariable}
%D and \type{\betavariable} is defined.

\def\dodoublewithset#1#2%
  {\def\dododoublewithset[##1][##2]%
     {\doifsomething{##1}
        {\def\dodododoublewithset####1{#2[####1][##2]}%
         \processcommalist[##1]\dodododoublewithset}}%
   #1\dododoublewithset}

\def\dodoubleemptywithset   {\dodoublewithset\dodoubleempty}
\def\dodoubleargumentwithset{\dodoublewithset\dodoubleargument}

\def\dotriplewithset#1#2%
  {\def\dodotriplewithset[##1][##2][##3]%
     {\doifsomething{##1}
        {\def\dododotriplewithset####1{#2[####1][##2][##3]}%
         \processcommalist[##1]\dododotriplewithset}}%
   #1\dodotriplewithset}

\def\dotripleemptywithset   {\dotriplewithset\dotripleempty}
\def\dotripleargumentwithset{\dotriplewithset\dotripleargument}

%>> Arguments handling (end) ———————————————————————————————————————— >>
%<< —— New \newif and globals ——————————————————————————————————————— >>

%D \macros
%D   {doglobal,
%D    redoglobal,dodoglobal,resetglobal}
%D
%D The two macros \type {\redoglobal} and \type{\dodoglobal} are
%D used in this and some other modules to enforce a user
%D specified \type {\doglobal} action. The last and often only
%D global assignment in a macro is done with
%D \type {\dodoglobal}, but all preceding ones with
%D \type {\redoglobal}. When using only alternatives, one can
%D reset this mechanism with \type {\resetglobal}.

\def\doglobal
  {\ifx\redoglobal\relax
     \let\redoglobal\global
     \let\dodoglobal\@@dodoglobal
   \fi}

\def\@@dodoglobal
  {\resetglobal\global}

\def\resetglobal
  {\let\redoglobal\relax
   \let\dodoglobal\relax}

\resetglobal

\def\saveglobal
  {\let\@@dodoglobal\dodoglobal
   \let\@@redoglobal\redoglobal}

\def\restoreglobal
  {\let\redoglobal\@@redoglobal
   \let\dodoglobal\@@dodoglobal}


%D \macros
%D   {newconditional,
%D    settrue, setfalse,
%D    ifconditional,then}
%D
%D \TEX's lacks boolean variables, although the \PLAIN\ format
%D implements \type{\newif}. The main disadvantage of this
%D scheme is that it takes three hash table entries. A more
%D memory saving alternative is presented here. A conditional
%D is defined by:

\def\settrue #1{\chardef#1\zerocount}
\def\setfalse#1{\chardef#1\plusone}

\let\newconditional = \setfalse
\let\ifconditional  = \ifcase

\let\then\relax % so that we can say \ifnum1>2\then -)

%>> New \newif and globals (end) ———————————————————————————————————— >>
%<< —— Robust grouped commands —————————————————————————————————————— >>

\long\def\HandleGroup#1#2%
  {\bgroup
   \long\def\BeforeGroup{\bgroup#1\bgroup\aftergroup\AfterGroup}%
   \long\def\AfterGroup {#2\egroup\egroup}%
   \afterassignment\BeforeGroup
   \let\next=}

\long\def\HandleSimpleGroup#1#2% no inner group (so no kerning interference)
  {\bgroup
   \long\def\BeforeGroup{\bgroup\aftergroup\AfterGroup#1}%
   \long\def\AfterGroup {#2\egroup}%
   \afterassignment\BeforeGroup
   \let\next=}

\long\def\HandleNoGroup#1#2%
  {\long\def\AfterGroup{#2\egroup}%
   \bgroup\aftergroup\AfterGroup#1}

\long\unexpanded\def\groupedcommand#1#2%
  {\doifnextbgroupelse{\HandleGroup{#1}{#2}}{\HandleNoGroup{#1}{#2}}}

\long\unexpanded\def\simplegroupedcommand#1#2%
  {\doifnextbgroupelse{\HandleSimpleGroup{#1}{#2}}{\HandleNoGroup{#1}{#2}}}

%>> Robust grouped commands (end) ——————————————————————————————————— >>
%<< —— Pseudo counters —————————————————————————————————————————————— >>

%D \macros
%D   {newcounter,
%D    increment,decrement}
%D
%D Unfortunately the number of \COUNTERS\ in \TEX\ is limited,
%D but fortunately we can store numbers in a macro. We can
%D increment such pseudo \COUNTERS\ with \type{\increment}.
%D
%D \starttyping
%D \increment(\counter,20)
%D \increment(\counter,-4)
%D \increment(\counter)
%D \increment\counter
%D \stoptyping
%D
%D \starttyping
%D \ifnum\normalcounter=\pseudocounter \doif \else \doelse \fi BAD
%D \ifnum\pseudocounter=\normalcounter \doif \else \doelse \fi GOOD
%D \stoptyping
%D
%D In the first test, \TEX\ continues it's search for the
%D second number after reading  \type{\pseudocounter}, while
%D in the second test, it stops reading after having
%D encountered a real one. Tests like the first one therefore
%D can give unexpected results, for instance execution
%D of \type{\doif} even if both numbers are unequal.

\def\zerocountervalue{0}

\def\ctxnewcounter#1%
  {\dodoglobal\let#1\zerocountervalue}

\def\!!zerocount {0} % alongside \zerocount
\def\!!minusone {-1} % alongside \minusone
\def\!!plusone   {1} % alongside \plusone

\def\dodoindecrement#1(#2,#3)%
  {\ifx#2\undefined
     \redoglobal\let#2\zerocountervalue
   \else\ifx#2\relax % \csname...\endcsname
     \redoglobal\let#2\zerocountervalue
   \fi\fi
   \scratchcounter#3\relax
   \scratchcounter#1\scratchcounter
   \advance\scratchcounter#2\relax
   \dodoglobal\edef#2{\the\scratchcounter}}

\def\dodoincrement(#1%
  {\doifnextcharelse,{\dodoindecrement+(#1}{\dodoindecrement+(#1,1}}

\def\dododecrement(#1%
  {\doifnextcharelse,{\dodoindecrement-(#1}{\dodoindecrement-(#1,1}}

\def\doincrement#1% 10% faster alternative
  {\ifx#1\undefined
     \dodoglobal\let#1\!!plusone
   \else\ifx#1\relax % \csname...\endcsname
     \dodoglobal\let#1\!!plusone
   \else
     \fastincrement#1%
   \fi\fi}

\def\dodecrement#1% 10% faster alternative
  {\ifx#1\undefined
     \dodoglobal\let#1\!!minusone
   \else\ifx#1\relax % \csname...\endcsname
     \dodoglobal\let#1\!!minusone
   \else
     \fastdecrement#1%
   \fi\fi}

\def\fastdecrement#1% 50% faster alternative
  {\scratchcounter#1\advance\scratchcounter\minusone
   \dodoglobal\edef#1{\the\scratchcounter}}

\def\fastincrement#1% 50% faster alternative
  {\scratchcounter#1\advance\scratchcounter\plusone
   \dodoglobal\edef#1{\the\scratchcounter}}

\def\increment{\doifnextcharelse(\dodoincrement\doincrement}
\def\decrement{\doifnextcharelse(\dododecrement\dodecrement}

\def\incrementvalue#1{\expandafter\increment\csname#1\endcsname}
\def\decrementvalue#1{\expandafter\decrement\csname#1\endcsname}


%D \macros
%D   {makecounter,pluscounter,minuscounter,
%D    resetcounter,setcounter,countervalue}
%D
%D Declaring, setting and resetting \COUNTERS\ can be done
%D with the next set of commands.
%D
%D \starttyping
%D \makecounter   {name}
%D \pluscounter   {name}
%D \minuscounter  {name}
%D \resetcounter  {name}
%D \setcounter    {name} {value}
%D \countervalue  {name}
%D \stoptyping
%D
%D We prefer the use of global counters. This means that we
%D have to load \PLAIN\ \TEX\ in a bit different way:
%D
%D \starttyping
%D \let\oldouter=\outer
%D \let\outer=\relax
%D \input plain.tex
%D \let\outer=\oldouter
%D
%D \def\newcount%
%D   {\alloc@0\count\countdef\insc@unt}
%D \stoptyping

\def\makecounter#1%
  {\letgvalue{#1}\zerocountervalue} % see earlier

\let\countervalue\getvalue

\def\pluscounter#1%
  {\scratchcounter\getvalue{#1}%
   \advance\scratchcounter \plusone
   \setxvalue{#1}{\the\scratchcounter}}

\def\minuscounter#1%
  {\scratchcounter\getvalue{#1}%
   \advance\scratchcounter \minusone
   \setxvalue{#1}{\the\scratchcounter}}

\def\resetcounter#1%
  {\letgvalue{#1}\zerocountervalue}

\def\setcounter#1#2%
  {\scratchcounter#2%
   \setxvalue{#1}{\the\scratchcounter}}

\def\incrementcounter#1#2% #1 name #2 value
   {\setxvalue{#1}{\the\numexpr\csname#1\endcsname+#2\relax}}

\def\decrementcounter#1#2% #1 name #2 value
   {\setxvalue{#1}{\the\numexpr\csname#1\endcsname-#2\relax}}


%D \macros
%D   {savecounter,restorecounter}
%D
%D These two commands can be used to save and restore counter
%D values. Only one level is saved.

\def\savecounter#1%
  {{\scratchcounter\getvalue {#1}\setxvalue{!#1}{\the\scratchcounter}}}

\def\restorecounter#1%
  {{\scratchcounter\getvalue{!#1}\setxvalue {#1}{\the\scratchcounter}}}

%>> Pseudo counters (end) ——————————————————————————————————————————— >>
%<< —— Convert into strings ————————————————————————————————————————— >>

%D \macros
%D   {convertargument,convertcommand,convertvalue}
%D
%D Some persistent experimenting led us to the next macro. This
%D macro converts a parameter or an expanded macro to it's
%D textual meaning.
%D
%D \starttyping
%D \convertargument ... \to \command
%D \stoptyping
%D
%D For example,
%D
%D \starttyping
%D \convertargument{one \two \three{four}}\to\ascii
%D \stoptyping
%D
%D The resulting macro \type{\ascii} can be written to a file
%D or the terminal without problems. In \CONTEXT\ we use this
%D macro for generating registers and tables of contents.
%D
%D The second conversion alternative accepts a command:
%D
%D \starttyping
%D \convertcommand\command\to\ascii
%D \stoptyping
%D
%D Both commands accept the prefix \type{\doglobal} for global
%D assignments.

\def\doconvertargument#1>{}

\def\convertedcommand
  {\expandafter\doconvertargument\meaning}

\long\def\convertargument#1\to#2%
  {\long\def#2{#1}% saves a restore
   \dodoglobal\edef#2{\convertedcommand#2}}

\long\def\convertcommand#1\to#2%
  {\dodoglobal\edef#2{\convertedcommand#1}}

% no dodoglobal !

\long\def\defconvertedargument#1#2% less sensitive for \to
  {\long\def#1{#2}% saves a restore
   \edef#1{\convertedcommand#1}}

\long\def\defconvertedcommand#1#2% less sensitive for \to
  {\edef#1{\convertedcommand#2}}

\long\def\gdefconvertedargument#1#2% less sensitive for \to
  {\long\gdef#1{#2}% saves a restore
   \xdef#1{\convertedcommand#1}}

\long\def\gdefconvertedcommand#1#2% less sensitive for \to
  {\xdef#1{\convertedcommand#2}}

\def\convertvalue#1\to
  {\expandafter\convertcommand\csname#1\endcsname\to}

\def\defconvertedvalue#1#2% less sensitive for \to
  {\@EA\defconvertedcommand\@EA#1\csname#2\endcsname}

%>> Convert into strings (end) —————————————————————————————————————— >>
%<< —— Setlocalhsize ———————————————————————————————————————————————— >>

%D \macros
%D   {setlocalhsize}
%D
%D Sometimes we need to work with the \type{\hsize} that is
%D corrected for indentation and left and right skips. The
%D corrected value is available in \type{\localhsize}, which
%D needs to be calculated with \type{\setlocalhsize} first.
%D
%D \starttyping
%D \setlocalhsize        \hbox to \localhsize{...}
%D \setlocalhsize[-1em]  \hbox to \localhsize{...}
%D \setlocalhsize[.5ex]  \hbox to \localhsize{...}
%D \stoptyping
%D
%D These examples show us that an optional can be used. The
%D value provided is added to \type{\localhsize}.

\newdimen\localhsize

\def\setlocalhsize{\doifnextoptionalelse\dosetlocalhsize{\dosetlocalhsize[\zeropoint]}}
\def\dolocalhsize[#1]% don't change !
  {\localhsize\hsize
   \ifnum\hangafter<\zerocount
     \advance\localhsize\ifdim\hangindent>\zeropoint-\fi\hangindent
   \fi
   \advance\localhsize -\leftskip
   \advance\localhsize -\rightskip
   \advance\localhsize #1\relax}

%>> Setlocalhsize (end) ————————————————————————————————————————————— >>
%<< —— dontleavehmode ——————————————————————————————————————————————— >>

%%TODO: WHAT DOES IT DO?
%D \macros
%D  {dontleavehmode}
%D
%D Sometimes when we enter a paragraph with some command, the
%D first token gets the whole first line. We can prevent this
%D by saying:
%D
%D \starttyping
%D \dontleavehmode
%D \stoptyping

\newbox\@@dlhbox

\unexpanded\def\dontleavehmode
  {\ifhmode\else \ifmmode\else
     \setbox\@@dlhbox\hbox{\mathsurround\zeropoint\everymath\emptytoks$ $}\unhbox\@@dlhbox
   \fi \fi}

%>> dontleavehmode (end) ———————————————————————————————————————————— >>
%<< —— Write strings ———————————————————————————————————————————————— >>

%D \macros
%D   {writestring,writeline,writebanner,
%D    writestatus,statuswidth,normalwritestatus}
%D
%D Maybe one didn't notice, but we've already introduced a
%D macro for showing messages. In the multi||lingual modules,
%D we will also introduce a mechanism for message passing. For
%D the moment we stick to the core macros:
%D
%D \starttyping
%D \writestring {string}
%D \writeline
%D \writestatus {category} {message}
%D \stoptyping
%D
%D Messages are formatted. One can provide the maximum with
%D of the identification string with the macro \type
%D {\statuswidth}.

\chardef\statuswidth=15
\chardef\statuswrite=16

\newtoks\everywritestring

\def\writedirect  {\immediate\write\statuswrite}
\def\writeline    {\writedirect{}}
\def\writestring#1{\begingroup\the\everywritestring\writedirect{#1}\endgroup}
\def\writestatus#1#2{\immediate\writedirect{#1 : #2}}
\def\writebanner{\writestring}


%D \macros
%D   {emptytoks}
%D
%D For this we need an empty token register, analogous
%D to \type {\empty}.

\newtoks\emptytoks

%>> Write strings (end) ————————————————————————————————————————————— >>

%D \macros
%D   {strutdp,strutht,strutwd}
%D
%D The next shortcuts save memory and keying. The width is
%D normally zero points (if not, you're in trouble). These
%D shortcuts can be used like a dimension, opposite to the
%D core macros \type {\strutdepth} and alike, which are
%D values.

\def\strutdp{\dp\strutbox}
\def\strutht{\ht\strutbox}
\def\strutwd{\wd\strutbox}


%D \macros
%D   {resetbox, emptybox}
%D
%D Let's start with an easy one. The next macro hides the
%D ugly \type {@} in \type {\voidb@x}.

\ifx\voidbox\undefined      \newbox\voidbox \fi
\ifx\voidb@x\undefined \let\voidb@x\voidbox \fi

\def\emptybox  {\box   \voidbox}
\def\unvoidbox {\unhbox\voidbox}
\def\resetbox#1{\setbox#1\box\voidbox}


%D \macros
%D   {nextdepth}
%D
%D Let's start with a rather simple declaration. Sometimes we
%D need to save the \TEX\ \DIMENSION\ \type{\prevdepth} and
%D append it later on. The name \type{\nextdepth} suits
%D this purpose well.

\newdimen\nextdepth


%D \macros
%D   {dowithnextbox,nextbox}
%D
%D Sometimes we want a macro to grab a box and do something
%D on the content. One could pass an argument to a box, but
%D this can violate the specific \CATCODES\ of its content and
%D leads to unexpected results. The next macro treats the
%D following braced text as the content of a box and
%D manipulates it afterwards in a predefined way.
%D
%D The first argument specifies what to do with the content.
%D This content is available in \type{\nextbox}. The second
%D argument is one of \type{\hbox}, \type{\vbox} or
%D \type{\vtop}. The third argument must be grouped with
%D \type{\bgroup} and \type{\egroup}, \type{{...}} or can be
%D a \type{\box} specification.
%D
%D In \CONTEXT\ this macro is used for picking up a box and
%D treating it according to earlier specifications. We use for
%D instance something like:
%D
%D \starttyping
%D \def\getfloat%
%D   {\def\handlefloat{...\flushnextbox...}
%D    \dowithnextbox\handlefloat\normalvbox}
%D \stoptyping
%D
%D instead of:
%D
%D \starttyping
%D \def\getfloat#1%
%D   {...#1...}
%D \stoptyping
%D
%D In this implementation the \type{\aftergroup} construction
%D is needed because \type{\afterassignment} is executed inside
%D the box.

\ifx\nextbox\undefined \newbox\nextbox \fi

\long\def\dowithnextbox#1%
  {\long\def\dodowithnextbox{#1}%
   \afterassignment\dododowithnextbox
   \setbox\nextbox}

\def\dododowithnextbox
  {\aftergroup\dodowithnextbox}

\long\def\dowithnextboxcs#1%
  {\let\dodowithnextbox#1%
   \afterassignment\dododowithnextbox
   \setbox\nextbox}

\def\dododowithnextbox
  {\aftergroup\dodowithnextbox}

%D So in fact we get:
%D
%D \starttyping
%D \setbox\nextbox { \aftergroup\dodowithnextbox ... }
%D \stoptyping
%D
%D or
%D
%D \starttyping
%D \setbox\nextbox { ... } \dodowithnextbox
%D \stoptyping
%D
%D A slower but more versatile implementation is:
%D
%D \starttyping
%D \long\def\dowithnextbox#1#2%
%D   {\long\def\dodowithnextbox{#1}%
%D    \ifx#2\normalhbox
%D      \afterassignment\dododowithnextbox
%D    \else\ifx#2\normalvbox
%D      \afterassignment\dododowithnextbox
%D    \else\ifx#2\normalvtop
%D      \afterassignment\dododowithnextbox
%D    \else\ifx#2\normalvcenter
%D      \afterassignment\dododowithnextbox
%D    \else
%D      \afterassignment\dodowithnextbox
%D    \fi\fi\fi\fi
%D    \setbox\nextbox#2}
%D \stoptyping
%D
%D This alternative also accepts \type{\box0} and alike, but
%D we don't really need this functionality now.

%D \macros
%D   {nextboxht,nextboxwd,nextboxdp,flushnextbox}
%D
%D The next couple of shortcuts saves us memory as well as
%D \type {{}}'s in passing parameters.

\def\nextboxht{\ht\nextbox}
\def\nextboxwd{\wd\nextbox}
\def\nextboxdp{\dp\nextbox}

\def\flushnextbox{\box\nextbox}


%D \macros
%D   {dowithnextboxcontent}
%D
%D But, occasionally we do need to pass some local settings
%D without wanting to use additional grouping. Therefore we
%D provide:
%D
%D \starttyping
%D \dowithnextboxcontent{inside}{after}{box content}
%D \stoptyping
%D
%D {\em todo: Search source for potential usage!}

\long\def\dowithnextboxcontent#1#2% inside, after
  {\long\def\dodowithnextbox{#2}%
   \def\dododowithnextbox{#1\aftergroup\dodowithnextbox}%
   \afterassignment\dododowithnextbox
   \setbox\nextbox}

\protect


%%% Local Variables:
%%% TeX-master: "./demo.tex"
%%% End:
