%D \module
%D   [       file=syst-gen,
%D        version=1996.03.20,
%D          title=\CONTEXT\ System Macros,
%D       subtitle=General,
%D         author=Hans Hagen,
%D           date=\currentdate,
%D      copyright={PRAGMA / Hans Hagen \& Ton Otten}]
%C
%C This module is part of the \CONTEXT\ macro||package and is
%C therefore copyrighted by \PRAGMA. See mreadme.pdf for
%C details.

%D Some of the macros will move to syst-obs as they might become
%D obsolete once we've redone the bibliography module. Of course
%D the handy helpers will stay.

%D This is a stripped down combination of:
%D
%D \startitemize
%D \item \type {syst-gen.tex}
%D \item \type {syst-ext.tex}
%D \item \type {syst-new.tex}
%D \stopitemize
%D
%D We keep them around (for \MKII) so you can find comments,
%D experiences, intermediate versions and cleaner variants
%D there (and also non-\ETEX\ variants).
%D
%D Contrary to the older files, we now assume that this one
%D is used in \CONTEXT\ and therefore we might also assume that
%D some basic functionality is available.
%D
%D Some of the macros here are used in the bibliography module. They
%D will be moved to a separate syst module some once the bib module
%D is made \MKIV.

%C Excerpts from the original file. Content has been reworked by
%C Cedric~Mauclair (2010) to work with LaTeX.

%<< —— Scratch variables and configuration stuff —————————————————— >>

%D The next few macros are needed in case this module is
%D used outside \CONTEXT.

\ifx\beginTEX\undefined
  \let\beginTEX\relax\let\endTEX\relax
  \long\def\beginETEX  #1\endETEX {}
\fi

%D \macros
%D   {globalletempty,letempty,letvalueempty,letgvalueempty}
%D
%D Trivial:

\def\letempty             #1{\let#1\empty}
\def\globalletempty#1{\global\let#1\empty}

\def\letvalueempty        #1{\expandafter\let\csname#1\endcsname\empty}
\def\letgvalueempty#1{\global\expandafter\let\csname#1\endcsname\empty}

%D \macros
%D   [protecting]
%D   {protect,unprotect}
%D
%D We can shield macros from users by using some special
%D characters in their names. Some characters that are normally
%D no letters and therefore often used are: \type{@}, \type{!}
%D and \type{?}. Before and after the definition of protected
%D macros, we have to change the \CATCODE\ of these characters.
%D This is done by \type{\unprotect} and \type{\protect}, for
%D instance:
%D
%D \starttyping
%D \unprotect
%D \def\!test{test}
%D \protect
%D \stoptyping
%D
%D The defined command \type{\!test} can of course only be
%D called upon when we are in the \type{\unprotect}'ed state,
%D otherwise \TEX\ reads \type{\!} and probably complains
%D loudly about not being in math mode.
%D
%D Both commands can be used nested, but only the \CATCODE\
%D of the outermost level is saved. We make use of
%D an auxilary macro \type{\doprotect} to prevent us from
%D conflicts with existing macro's \type{\protect}. When
%D nesting deeper than one level, the system shows the
%D protection level.

\ifx\protectionlevel\undefined \newcount\protectionlevel \fi

\ifx\protect\undefined
  \def\protect{\writestatus{protection}{too much protection}}
\else
  % a simple version is already defined
\fi

\let\normalprotect\protect % only for latex

%D Although we don't need the \type{%} after commands that
%D don't take arguments, unless lines are obeyed, I decided
%D to put it there as a reminder. I only mention this once.

\ifx\unprotect\undefined

    \chardef\protectionthreshold=10

    \def\saveprotectedcharacters
      {\edef\doprotectcharacters
         {\catcode`\noexpand @\the\catcode`@
          \catcode`\noexpand !\the\catcode`!
          \catcode`\noexpand ?\the\catcode`? }}

    \def\setprotectedcharacters
      {\catcode`@=11
       \catcode`!=11
       \catcode`?=11 }

    \def\unprotect
      {\ifcase\protectionlevel
         \saveprotectedcharacters
         \let\protect\doprotect
       \fi
       \setprotectedcharacters
       \advance\protectionlevel 1
       \ifnum\protectionlevel>\protectionthreshold
         \reportunprotection
       \fi}

    \def\doprotect
      {\ifcase\protectionlevel\or
         \doprotectcharacters
         \let\doprotectcharacters\relax
         \let\protect\normalprotect
       \fi
       \ifnum\protectionlevel>\protectionthreshold
         \reportprotection
       \fi
       \advance\protectionlevel -1 }

    \def\reportunprotection   {\writestatus{protection}{unprotect \protectionstate}}
    \def\reportprotection     {\writestatus{protection}{protect   \protectionstate}}
    \def\reportprotectionstate{\writestatus{protection}{state     \protectionstate}}

    \def\protectionstate
      {\the\protectionlevel
       \ifcase\protectionthreshold
         :\space
         @=\the\catcode`@\space\space
         !=\the\catcode`!\space\space
         ?=\the\catcode`?%
       \fi}

    \ifx\everyeof\undefined
        \let\checkprotection\relax
    \else
        \def\checkprotection{\everyeof{\writestatus{protection}{state: \protectionstate}}}
    \fi

\else

    \let\reportprotectionstate\relax

\fi

%D Now it is defined, we can make use of this very useful
%D macro.

\unprotect

\def\dounprotected#1\par
  {#1\protect}

\def\unprotected
  {\unprotect\dounprotected}

%D \macros
%D   {@@escape,@@begingroup,@@endgroup,@@mathshift,@@alignment,
%D    @@endofline,@@parameter,@@superscript,@@subscript,
%D    @@ignore,@@space,@@letter,@@other,@@active,@@comment}
%D
%D In \CONTEXT\ we sometimes manipulate the \CATCODES\ of
%D certain characters. Because we are not that good at numbers,
%D we introduce some symbolic names.

\chardef\@@escape      =  0
\chardef\@@begingroup  =  1
\chardef\@@endgroup    =  2
\chardef\@@mathshift   =  3
\chardef\@@alignment   =  4
\chardef\@@endofline   =  5
\chardef\@@parameter   =  6
\chardef\@@superscript =  7
\chardef\@@subscript   =  8
\chardef\@@ignore      =  9
\chardef\@@space       = 10
\chardef\@@letter      = 11
\chardef\@@other       = 12   \chardef\other  = 12
\chardef\@@active      = 13   \chardef\active = 13
\chardef\@@comment     = 14

%D \macros
%D   {normalspace}
%D
%D We often need a space as defined in \PLAIN\ \TEX. Because
%D we cannot be sure of \type{\space} is redefined, we define:

\def\normalspace{ }

%D \macros
%D   {scratchcounter,
%D    scratchdimen,scratchskip,scratchmuskip,
%D    scratchbox,
%D    scratchtoks}
%D
%D Because we often need counters on a temporary basis, we
%D define the \COUNTER\ \type{\scratchcounter}. This is a
%D real \COUNTER, and not a pseudo one, as we will meet
%D further on. We also define some other scratch registers.

\chardef\newabovelimit=20

\def\stripnewabove#1%
  {\ifnum10<9#1 #1\else\expandafter\stripnewabove\fi}%

\def\newabove#1#2% \dimen \name
  {#1#2%
   \ifnum\expandafter\stripnewabove\meaning#2>\newabovelimit\else
     \expandafter\newabove\expandafter#1\expandafter#2%
   \fi}

\newabove \newcount   \scratchcounter   \newabove \newcount  \globalscratchcounter
\newabove \newdimen   \scratchdimen     \newabove \newdimen  \globalscratchdimen
\newabove \newskip    \scratchskip      \newabove \newskip   \globalscratchskip
\newabove \newmuskip  \scratchmuskip    \newabove \newmuskip \globalscratchmuskip
\newabove \newtoks    \scratchtoks      \newabove \newtoks   \globalscratchtoks
          \newbox     \scratchbox                 \newbox    \globalscratchbox

\newdimen\scratchdimenone \newbox\scratchboxone \newcount\scratchcounterone
\newdimen\scratchdimentwo \newbox\scratchboxtwo \newcount\scratchcountertwo

%D \macros
%D   {ifdone}

\newif\ifdone

%D \macros
%D   {ifCONTEXT}
%D
%D In the system and support modules we sometimes show examples
%D that make use of core commands. We can skip those parts of
%D the documentation when we use another macropackage. Of
%D course we default to false.

\newif \ifCONTEXT

%D \macros
%D   {!!count, !!toks, !!dimen, !!box,
%D    !!width, !!height, !!depth, !!string, !!done}
%D
%D We define some more \COUNTERS\ and \DIMENSIONS. We also
%D define some shortcuts to the local scatchregisters~0, 2, 4,
%D 6 and~8.

\newcount\!!counta \newtoks\!!toksa \newdimen\!!dimena \newbox\!!boxa
\newcount\!!countb \newtoks\!!toksb \newdimen\!!dimenb \newbox\!!boxb
\newcount\!!countc \newtoks\!!toksc \newdimen\!!dimenc \newbox\!!boxc
\newcount\!!countd \newtoks\!!toksd \newdimen\!!dimend \newbox\!!boxd
\newcount\!!counte \newtoks\!!tokse \newdimen\!!dimene \newbox\!!boxe
\newcount\!!countf \newtoks\!!toksf \newdimen\!!dimenf \newbox\!!boxf
                                    \newdimen\!!dimeng
                                    \newdimen\!!dimenh
                                    \newdimen\!!dimeni
                                    \newdimen\!!dimenj
                                    \newdimen\!!dimenk

\let\!!stringa\empty \let\!!stringb\empty \let\!!stringc\empty
\let\!!stringd\empty \let\!!stringe\empty \let\!!stringf\empty

\newdimen\!!widtha \newdimen\!!heighta \newdimen\!!deptha
\newdimen\!!widthb \newdimen\!!heightb \newdimen\!!depthb
\newdimen\!!widthc \newdimen\!!heightc \newdimen\!!depthc
\newdimen\!!widthd \newdimen\!!heightd \newdimen\!!depthd

\newif\if!!donea   \newif\if!!doneb    \newif\if!!donec
\newif\if!!doned   \newif\if!!donee    \newif\if!!donef

\ifx\data\undefined \else \let\data \relax \fi % dep checker

%D Beware: we don't reuse plain counters, too dangerous
%D when <= 20 (e.g. in supp-pdf this messed up things).

\ifx\undefined\zeroskip           \newskip     \zeroskip                   \fi
\ifx\undefined\zeropoint          \newdimen    \zeropoint                  \fi
\ifx\undefined\zerocount          \newcount    \zerocount                  \fi
\ifx\undefined\minusone           \newcount    \minusone                   \fi \minusone = -1
\ifx\undefined\minustwo           \newcount    \minustwo                   \fi \minustwo = -2
\ifx\undefined\plusone            \chardef     \plusone            =     1 \fi
\ifx\undefined\plustwo            \chardef     \plustwo            =     2 \fi
\ifx\undefined\plusthree          \chardef     \plusthree          =     3 \fi
\ifx\undefined\plusfour           \chardef     \plusfour           =     4 \fi
\ifx\undefined\plusfive           \chardef     \plusfive           =     5 \fi
\ifx\undefined\plusten            \mathchardef \plusten            =    10 \fi
\ifx\undefined\plushundred        \mathchardef \plushundred        =   100 \fi
\ifx\undefined\plusthousand       \mathchardef \plusthousand       =  1000 \fi
\ifx\undefined\plustenthousand    \mathchardef \plustenthousand    = 10000 \fi
\ifx\undefined\plustwentythousand \mathchardef \plustwentythousand = 20000 \fi

%D \macros
%D   {s!,c!,e!,p!,v!,@@,??}
%D
%D To save memory, we use constants (sometimes called
%D variables). Redefining these constants can have disastrous
%D results.

\def\v!prefix! {v!}           \def\c!prefix! {c!}
\def\s!prefix! {s!}           \def\p!prefix! {p!}

\def\s!next    {next}         \def\s!default {default}
\def\s!dummy   {dummy}        \def\s!unknown {unknown}

\def\s!do      {do}           \def\s!dodo    {dodo}

\def\s!complex {complex}      \def\s!start   {start}
\def\s!simple  {simple}       \def\s!stop    {stop}

\def\s!empty   {empty}

%D \macros
%D   {@EA,@EAEA,@EAEAEA,@EAEAEAEAEAEA,expanded,startexpanded}
%D
%D When in unprotected mode, to be entered with
%D \type{\unprotect}, one can use \type{\@EA} as equivalent
%D of \type{\expandafter}.

\let\@NX\noexpand
\let\@EA\expandafter

\def\@EAEA  {\expandafter\expandafter}
\def\@EAEAEA{\expandafter\expandafter\expandafter}

\def\@EAEAEAEAEAEA{\expandafter\@EAEAEA\expandafter}

%>> Scratch variables and configuration stuff (end) ——————————————— >>
%<< —— Expansion & gobbles ———————————————————————————————————————— >>

%D \macros
%D   {strippedcsname}
%D
%D The next macro can be very useful when using \type{\csname}
%D like in:
%D
%D \starttyping
%D \csname if\strippedcsname\something\endcsname
%D \stoptyping
%D
%D This expands to \type{\ifsomething}.

\ifx\letterbackslash\undefined
  {\catcode`.=0 .catcode`.\ 12 .xdef.letterbackslash{.string\}} % hack
\fi

\def\strippedcsname#1% this permits \strippedcsname{\xxx} and \strippedcsname{xxx}
  {\expandafter\dostrippedcsname\string#1}

\def\dostrippedcsname#1%
  {\if\noexpand#1\letterbackslash\else#1\fi}

%D \macros
%D   {savenormalmeaning}
%D
%D We will use this one in:

\def\savenormalmeaning#1%
  {\ifundefined{normal\strippedcsname#1}%
     \letvalue{normal\strippedcsname#1}#1%
   \fi}

%D Sometimes we pass macros as arguments to commands that
%D don't expand them before interpretation. Such commands can
%D be enclosed with \type{\expanded}, like:
%D
%D \starttyping
%D \expanded{\setupsomething[\alfa]}
%D \stoptyping
%D
%D Such situations occur for instance when \type{\alfa} is a
%D commalist or when data stored in macros is fed to index of
%D list commands. If needed, one should use \type{\noexpand}
%D inside the argument. Later on we will meet some more clever
%D alternatives to this command.

\long\def\@@expanded{} % always long; global (less restores)

\long\def\expanded#1%
  {\long\xdef\@@expanded{\noexpand#1}\@@expanded}

%D Beware, the next one has no \type {\noexpand} before its
%D argument.

\long\def\startexpanded#1\stopexpanded % see x-fo for example
  {\long\xdef\@@expanded{#1}\@@expanded}

%D Recent \TEX's have a primitive \expanded

% \long\def\expanded
%   {\normalexpanded\bgroup\noexpand\gobblenexttoken}

%D \macros
%D   {safeexpanded,everysafeexpanded}
%D
%D In addition we provide:

\newtoks\everysafeexpanded

\long\def\safeexpanded#1% why the \noexpand
  {\begingroup
   \the\everysafeexpanded\long\xdef\@@expanded{\noexpand#1}%
   \endgroup
   \@@expanded}

\def\safeedef#1#2%
  {\begingroup
   \the\everysafeexpanded\long\xdef\@@expanded{\noexpand#2}%
   \endgroup
   \let#1\@@expanded}

\def\safexdef#1#2%
  {\begingroup
   \the\everysafeexpanded\long\xdef\@@expanded{\noexpand#2}%
   \endgroup
   \global\let#1\@@expanded}

%D You can append protective measures to the token register if
%D needed, as we will do later.

%D \macros
%D   {donottest,unexpanded}
%D
%D When expansion of a macro gives problems, we can precede it
%D by \type{\donottest}. It seems that protection is one of the
%D burdens of developers of packages, so maybe that's why in
%D \ETEX\ protection is solved in a more robust way.
%D
%D Sometimes prefixing the macro with \type{\donottest} leads
%D to defining an auxiliary macro, like
%D
%D \starttyping
%D \def\dosomecommand {... ... ...}
%D \def\somecommand   {\donottest\dosomecommand}
%D \stoptyping
%D
%D This double definition can be made transparant by using
%D \type{\unexpanded}, as in:
%D
%D \starttyping
%D \unexpanded\def\somecommand{... ... ...}
%D \stoptyping
%D
%D The protection mechanism uses:

\def\dontprocesstest#1{==}
\def\doprocesstest  #1{#1}

\let\donottest=\doprocesstest

%D By the way, we use a placeholder because we don't want
%D interference when testing on empty strings. Using a
%D placeholder of 8~characters increases the processing time
%D of simple \type{\doifelse} tests by about 10 \%. When we
%D process the test, we have to remove the braces and
%D therefore explictly gobble \type{#1}.

%D \macros
%D   {honorunexpanded,forceunexpanded}
%D
%D The fact that many macros have the same prefix, could have
%D a negative impact on searching in the hash table. Because
%D some simple testing does not show differences, we just use:
%D
%D \starttyping
%D \def\unexpanded#1#2%
%D   {\@EA#1\@EA#2\@EA{\@EA\donottest\csname\s!do\string#2\endcsname}%
%D    \@EA#1\csname\s!do\string#2\endcsname}
%D \stoptyping
%D
%D Well, in fact we use the bit more versatile alternative. The
%D \type {\honorunexpanded} can be used to \type {\string}
%D the protected command, which by the way is seldom needed
%D in \CONTEXT.

\def\dosetunexpanded#1#2%
  {\@EA#1\@EA{\@EA#2\@EA}%
     \@EA{\@EA\donottest\csname\s!do\@EA\string\csname#2\endcsname\endcsname}%
   \@EA#1\@EA{\@EA\s!do\@EA\string\csname#2\endcsname}}

\def\docomunexpanded#1#2%
  {\@EA#1\@EA#2\@EA{\@EA\donottest\csname\s!do\string#2\endcsname}%
   \@EA#1\csname\s!do\string#2\endcsname}

\def\unexpanded#1%
  {\def\dounexpanded
     {\ifx\next\bgroup
        \@EA\dosetunexpanded
      \else
        \@EA\docomunexpanded
      \fi#1}%
   \futurelet\next\dounexpanded}

\def\honorunexpanded% for writing to a file or message
  {\def\donottest##1{\expandafter\gobblethreearguments\string##1}}

\def\forceunexpanded% for preventing expansion in \xdef
  {\def\donottest##1%
     {\expandafter\noexpand\csname\expandafter\gobblefourarguments\string##1\endcsname}}

\def\resetunexpanded%
  {\let\donottest\doprocesstest}

%D \macros
%D   {expandoneargafter,expandtwoargsafter}
%D
%D These two commands make macros more readable by hiding a
%D lot of \type {\expandafter}'s. They expand the arguments
%D after the first command.
%D
%D \starttyping
%D \expandoneargafter \command{\abc}
%D \expandtwoargsafter\command{\abc}{\def}
%D \stoptyping
%D
%D These commands expect the arguments to be macros.

\def\expandoneargafter   #1{\@EA#1\@EA}
\def\expandtwoargsafter#1#2{\@EA\@EA\@EA#1\@EA\@EA\@EA{\@EA#2\@EA}\@EA}

%D These two do a full expansion:

\def\fullexpandoneargafter   #1#2{\long\xdef\@@expanded{\noexpand#1{#2}}\@@expanded}
\def\fullexpandtwoargsafter#1#2#3{\long\xdef\@@expanded{\noexpand#1{#2}{#3}}\@@expanded}

%D \macros
%D   {ExpandFirstAfter,ExpandSecondAfter,ExpandBothAfter}
%D
%D These three commands support expansion of arguments before
%D executing the commands that uses them. We can best
%D illustrate this with an example.
%D
%D \starttyping
%D \def\first  {alfa,beta,gamma}
%D \def\second {alfa,epsilon,zeta}
%D
%D \ExpandFirstAfter  \doifcommon {\first} {alfa}    {\message{OK}}
%D \ExpandSecondAfter \doifcommon {alfa}   {\second} {\message{OK}}
%D \ExpandBothAfter   \doifcommon {\first} {\second} {\message{OK}}
%D
%D \ExpandFirstAfter\processcommalist[\first]\message
%D
%D \ExpandAfter       \doifcommon {\first} {alfa}    {\message{OK}}
%D \stoptyping
%D
%D The first three calls result in the threefold message
%D \type{OK}, the fourth one shows the three elements of
%D \type{\first}. The command \type{\ExpandFirstAfter} takes
%D care of (first) arguments that are delimited by \type{[ ]},
%D but the faster \type{\ExpandAfter} does not.

\def\simpleExpandFirstAfter#1%
  {\long\xdef\@@expanded{\noexpand\ExpandCommand{#1}}\@@expanded}

\def\complexExpandFirstAfter[#1]%
  {\long\xdef\@@expanded{\noexpand\ExpandCommand[#1]}\@@expanded}

\def\ExpandFirstAfter#1%
  {\let\ExpandCommand#1%
   \doifnextoptionalelse\complexExpandFirstAfter\simpleExpandFirstAfter}

\def\ExpandSecondAfter#1#2#3%
  {\scratchtoks{#2}%
   \long\xdef\@@expanded{\noexpand#1{\the\scratchtoks}{#3}}\@@expanded}

\def\ExpandBothAfter#1#2#3%
  {\long\xdef\@@expanded{\noexpand#1{#2}{#3}}\@@expanded}

\def\ExpandAfter#1#2%
  {\long\xdef\@@expanded{\noexpand#1{#2}}\@@expanded}

%D Now we can for instance define \type{\ifinstringelse} as:

\def\ifinstringelse
  {\ExpandBothAfter\p!doifinstringelse}

%D \macros
%D   {gobbleoneargument,gobble...arguments}
%D
%D The next set of macros just do nothing, except that they
%D get rid of a number of arguments.

\long\def\gobbleoneargument    #1{}
\long\def\gobbletwoarguments   #1#2{}
\long\def\gobblethreearguments #1#2#3{}
\long\def\gobblefourarguments  #1#2#3#4{}
\long\def\gobblefivearguments  #1#2#3#4#5{}
\long\def\gobblesixarguments   #1#2#3#4#5#6{}
\long\def\gobblesevenarguments #1#2#3#4#5#6#7{}
\long\def\gobbleeightarguments #1#2#3#4#5#6#7#8{}
\long\def\gobbleninearguments  #1#2#3#4#5#6#7#8#9{}
\long\def\gobbletenarguments   #1{\gobbleninearguments}

%D \macros
%D   {gobbleuntil,grabuntil,gobbleuntilrelax,
%D    processbetween,processuntil}
%D
%D In \TEX\ gobbling usually stand for skipping arguments, so
%D here are our gobbling macros.
%D
%D In \CONTEXT\ we use a lot of \type{\start}||\type{\stop}
%D like constructions. Sometimes, the \type{\stop} is used as a
%D hard coded delimiter like in:
%D
%D \starttyping
%D \def\startcommand#1\stopcommand%
%D   {... #1 ...}
%D \stoptyping
%D
%D In many cases the \type{\start}||\type{\stop} pair is
%D defined at format generation time or during a job. This
%D means that we cannot hardcode the \type{\stop} criterium.
%D Only after completely understanding \type{\csname} and
%D \type{\expandafter} I was able to to implement a solution,
%D starting with:
%D
%D \starttyping
%D \grabuntil{stop}\command
%D \stoptyping
%D
%D This commands executes, after having encountered
%D \type {\stop} the command \type {\command}. This command
%D receives as argument the text preceding the \type {\stop}.
%D This means that:
%D
%D \starttyping
%D \def\starthello%
%D   {\grabuntil{stophello}\message}
%D
%D \starthello Hello world!\stophello
%D \stoptyping
%D
%D results in: \type{\message{Hello world!}}.

\def\dograbuntil#1#2%
  {\long\def\next##1#1{#2{##1}}\next}

\def\grabuntil#1%
  {\expandafter\dograbuntil\expandafter{\csname#1\endcsname}}

%D The next command build on this mechanism:
%D
%D \starttyping
%D \processbetween{string}\command
%D \stoptyping
%D
%D Here:
%D
%D \starttyping
%D \processbetween{hello}\message
%D \starthello Hello again!\stophello
%D \stoptyping
%D
%D leads to: \type{\message{Hello again!}}. The command
%D
%D \starttyping
%D \gobbleuntil{sequence}
%D \stoptyping
%D
%D is related to these commands. This one simply throws away
%D everything preceding \type{\command}.

\long\def\processbetween#1#2%
  {\setvalue{#1}{\grabuntil{\end#1}{#2}}}

\def\gobbleuntil#1%
  {\long\def\next##1#1{}\next}

\def\gobbleuntilrelax#1\relax
  {}

%D The next one simply expands the pickup up tokens.
%D
%D \starttyping
%D \processuntil{sequence}
%D \stoptyping

\def\processuntil#1%
  {\long\def\next##1#1{##1}\next}

%>> Expansion & gobbles (end) ————————————————————————————————————— >>
%<< —— Checking next character ———————————————————————————————————— >>

%D \macros
%D   {doifnextcharelse}

\long\def\doifnextcharelse#1#2#3% #1 should not be {} !
  {\let\charactertoken=#1% = needed here
   \def\!!stringa{#2}%
   \def\!!stringb{#3}%
   \futurelet\nexttoken\inspectnextcharacter}

\def\inspectnextcharacter
  {\ifx\nexttoken\blankspace
     \@EA\reinspectnextcharacter
   \else\ifx\nexttoken\charactertoken
     \@EAEAEA\!!stringa
   \else
     \@EAEAEA\!!stringb
   \fi\fi}

%D Because we will mostly use this macro for testing if the next
%D character is \type {[}, we also make a slightly faster variant
%D as it is not uncommon to have tens of thousands of calls to this
%D test in a run. Of course it also is more convenient to read a
%D trace then.

\let\nextoptionalcharactertoken=[

\long\def\doifnextoptionalelse#1#2%
  {\def\nextoptionalcommandyes{#1}%
   \def\nextoptionalcommandnop{#2}%
   \futurelet\nexttoken\inspectnextoptionalcharacter}

\def\inspectnextoptionalcharacter
  {\ifx\nexttoken\blankspace
     \@EA\reinspectnextoptionalcharacter
   \else\ifx\nexttoken\nextoptionalcharactertoken
     \@EAEAEA\nextoptionalcommandyes
   \else
     \@EAEAEA\nextoptionalcommandnop
   \fi\fi}

\let\nextbgroupcharactertoken\bgroup

\long\def\doifnextbgroupelse#1#2%
  {\def\nextbgroupcommandyes{#1}%
   \def\nextbgroupcommandnop{#2}%
   \futurelet\nexttoken\inspectnextbgroupcharacter}

\def\inspectnextbgroupcharacter
  {\ifx\nexttoken\blankspace
     \@EA\reinspectnextbgroupcharacter
   \else\ifx\nexttoken\nextbgroupcharactertoken
     \@EAEAEA\nextbgroupcommandyes
   \else
     \@EAEAEA\nextbgroupcommandnop
   \fi\fi}

%D This macro uses some auxiliary macros. Although we were able
%D to program quite complicated things, I only understood these
%D after rereading the \TEX book. The trick is in using a
%D command with a one character name. Such commands differ from
%D the longer ones in the fact that trailing spaces are {\em
%D not} skipped. This enables us to indirectly define a long
%D named macro that gobbles a space.
%D
%D In the first line we define \type{\blankspace}. Next we
%D make \type{\:} equivalent to \type{\reinspect...}. This
%D one||character command is expanded before the next
%D \type{\def} comes into action. This way the space after
%D \type{\:} becomes a delimiter of the longer named
%D \type{\reinspectnextcharacter}. The chain reaction is
%D visually compatible with the next sequence:
%D
%D \starttyping
%D \expandafter\def\reinspectnextcharacter %
%D   {\futurelet\nexttoken\inspectnextcharacter}
%D \stoptyping

\let\next\:

\def\:{\let\blankspace= }  \:

\def\:{\reinspectnextcharacter}
\expandafter\def\: {\futurelet\nexttoken\inspectnextcharacter}

\def\:{\reinspectnextoptionalcharacter}
\expandafter\def\: {\futurelet\nexttoken\inspectnextoptionalcharacter}

\def\:{\reinspectnextbgroupcharacter}
\expandafter\def\: {\futurelet\nexttoken\inspectnextbgroupcharacter}

\let\:\next

%>> Checking next character (end) ————————————————————————————————— >>
%<< —— Variables (macros witout '\' or \csname ... \endcsname) ———— >>

%D \macros
%D   {setvalue,setgvalue,setevalue,setxvalue,
%D    letvalue,
%D    getvalue,
%D    resetvalue}
%D
%D \TEX's primitive \type{\csname} can be used to construct
%D all kind of commands that cannot be defined with
%D \type{\def} and \type{\let}. Every macro programmer sooner
%D or later wants macros like these.
%D
%D \starttyping
%D \setvalue   {name}{...} = \def\name{...}
%D \setgvalue  {name}{...} = \gdef\name{...}
%D \setevalue  {name}{...} = \edef\name{...}
%D \setxvalue  {name}{...} = \xdef\name{...}
%D \letvalue   {name}=\... = \let\name=\...
%D \letgvalue  {name}=\... = \global\let\name=\...
%D \getvalue   {name}      = \name
%D \resetvalue {name}      = \def\name{}
%D \stoptyping

\def\setvalue     #1{\expandafter \def\csname#1\endcsname}
\def\setgvalue    #1{\expandafter\gdef\csname#1\endcsname}
\def\setevalue    #1{\expandafter\edef\csname#1\endcsname}
\def\setxvalue    #1{\expandafter\xdef\csname#1\endcsname}
\def\getvalue     #1{\csname#1\endcsname}
\def\letvalue     #1{\expandafter\let\csname#1\endcsname}
\def\letgvalue    #1{\global\expandafter\let\csname#1\endcsname}
\def\resetvalue   #1{\expandafter\let\csname#1\endcsname\empty}
\def\ignorevalue#1#2{\expandafter\let\csname#1\endcsname\empty}

%D \macros
%D   {globallet,glet}

\def\globallet{\global\let}  \let\glet\globallet

%D \macros
%D   {showvalue,showargument}
%D
%D Two handy macros for testing purposes only:

\def\showvalue#1%
  {\expandafter\show\csname#1\endcsname}

\long\def\showargument#1%
  {\defconvertedargument\ascii{#1}\ascii}

%>> Variables (macros witout '\' or \csname ... \endcsname) (end) — >>
%<< —— Check ifdefined ———————————————————————————————————————————— >>

%D \macros
%D   {doifundefined,doifdefined,
%D    doifundefinedelse,doifdefinedelse,
%D    doifalldefinedelse}
%D
%D \starttyping
%D \doifundefined      {string}    {...}
%D \doifdefined        {string}    {...}
%D \doifundefinedelse  {string}    {then ...} {else ...}
%D \doifdefinedelse    {string}    {then ...} {else ...}
%D \doifalldefinedelse {commalist} {then ...} {else ...}
%D \stoptyping

\def\ifundefined#1%
  {\expandafter\ifx\csname#1\endcsname\relax}

\def\p!doifundefined#1%
  {\let\donottest\dontprocesstest
   \expandafter\ifx\csname#1\endcsname\relax}

\def\doifundefinedelse#1%
  {\p!doifundefined{#1}%
     \let\donottest\doprocesstest\@EA\firstoftwoarguments
   \else
     \let\donottest\doprocesstest\@EA\secondoftwoarguments
   \fi}

\def\doifdefinedelse#1%
  {\p!doifundefined{#1}%
     \let\donottest\doprocesstest\@EA\secondoftwoarguments
   \else
     \let\donottest\doprocesstest\@EA\firstoftwoarguments
   \fi}

\def\doifundefined#1%
  {\p!doifundefined{#1}%
     \let\donottest\doprocesstest\@EA\firstofoneargument
   \else
     \let\donottest\doprocesstest\@EA\gobbleoneargument
   \fi}

\def\doifdefined#1%
  {\p!doifundefined{#1}%
     \let\donottest\doprocesstest\@EA\gobbleoneargument
   \else
     \let\donottest\doprocesstest\@EA\firstofoneargument
   \fi}

%D \macros
%D   {letbeundefined}
%D
%D Testing for being undefined comes down to testing on \type
%D {\relax} when we use \type {\csname}, but when using \type
%D {\ifx}, we test on being \type {\undefined}! In \ETEX\ we
%D have \type {\ifcsname} and that way of testing on existance
%D is not the same as the one described here. Therefore we
%D introduce:

\def\letbeundefined#1%
  {\expandafter\let\csname#1\endcsname\relax}

\def\docheckonedefined#1%
  {\ifundefined{#1}%
     \donefalse
   \fi}

\def\doifalldefinedelse#1%
  {\begingroup
   \let\donottest\dontprocesstest
   \donetrue
   \processcommalist[#1]\docheckonedefined
   \ifdone
     \endgroup\let\donottest\doprocesstest
     \expandafter\firstoftwoarguments
   \else
     \endgroup\let\donottest\doprocesstest
     \expandafter\secondoftwoarguments
   \fi}

%>> Check ifdefined (end) ————————————————————————————————————————— >>
%<< —— doifs —————————————————————————————————————————————————————— >>

%D \macros
%D   {doif,doifelse,doifnot,
%D    donottest}
%D
%D \starttyping
%D \doif     {string1} {string2} {...}
%D \doifnot  {string1} {string2} {...}
%D \doifelse {string1} {string2} {then ...}{else ...}
%D \stoptyping
%D
%D When expansion gives problems, we can precede the
%D troublemaker with \type{\donottest}.

\long\def\doif#1#2%
  {\let\donottest\dontprocesstest
   \edef\!!stringa{#1}%
   \edef\!!stringb{#2}%
   \let\donottest\doprocesstest
   \ifx\!!stringa\!!stringb
     \expandafter\firstofoneargument
   \else
     \expandafter\gobbleoneargument
   \fi}

\long\def\doifnot#1#2%
  {\let\donottest\dontprocesstest
   \edef\!!stringa{#1}%
   \edef\!!stringb{#2}%
   \let\donottest\doprocesstest
   \ifx\!!stringa\!!stringb
     \expandafter\gobbleoneargument
   \else
     \expandafter\firstofoneargument
   \fi}


\long\def\doifelse#1#2%
  {\let\donottest\dontprocesstest
   \edef\!!stringa{#1}%
   \edef\!!stringb{#2}%
   \let\donottest\doprocesstest
   \ifx\!!stringa\!!stringb
     \expandafter\firstoftwoarguments
   \else
     \expandafter\secondoftwoarguments
   \fi}

%D \macros
%D   {doifempty,doifemptyelse,doifnotempty}
%D
%D We complete our set of conditionals with:
%D
%D \starttyping
%D \doifempty     {string} {...}
%D \doifnotempty  {string} {...}
%D \doifemptyelse {string} {then ...} {else ...}
%D \stoptyping
%D
%D This time, the string is not expanded.

\long\def\doifemptyelse#1%
  {\def\!!stringa{#1}%
   \ifx\!!stringa\empty
     \expandafter\firstoftwoarguments
   \else
     \expandafter\secondoftwoarguments
   \fi}

\long\def\doifempty#1%
  {\def\!!stringa{#1}%
   \ifx\!!stringa\empty
     \expandafter\firstofoneargument
   \else
     \expandafter\gobbleoneargument
   \fi}

\long\def\doifnotempty#1%
  {\def\!!stringa{#1}%
   \ifx\!!stringa\empty
     \expandafter\gobbleoneargument
   \else
     \expandafter\firstofoneargument
   \fi}

%D \macros
%D   {doifinset,doifnotinset,doifinsetelse}
%D
%D \starttyping
%D \doifinset     {string} {string,...} {...}
%D \doifnotinset  {string} {string,...} {...}
%D \doifinsetelse {string} {string,...} {then ...} {else ...}
%D \stoptyping

\def\p!docheckiteminset#1%
  {\edef\!!stringb{#1}%
   \ifx\!!stringa\!!stringb
     \donetrue
     \expandafter\quitcommalist
   \fi}

\def\p!doifinsetelse#1#2#3#4%
  {\let\donottest\dontprocesstest
   \donefalse
   \edef\!!stringa{#3}%
   \ifx\!!stringa\empty
   \else
     \processcommalist[#4]\p!docheckiteminset
   \fi
   \let\donottest\doprocesstest
   \ifdone\expandafter#1\else\expandafter#2\fi}

\long\def\doifinsetelse
  {\p!doifinsetelse\firstoftwoarguments\secondoftwoarguments}

\long\def\doifinset
  {\p!doifinsetelse\firstofoneargument\gobbleoneargument}

\long\def\doifnotinset
  {\p!doifinsetelse\gobbleoneargument\firstofoneargument}

%D \macros
%D   {doifcommon,doifnotcommon,doifcommonelse}
%D
%D Probably the most time consuming tests are those that test
%D for overlap in sets of strings.
%D
%D \starttyping
%D \doifcommon     {string,...} {string,...} {...}
%D \doifnotcommon  {string,...} {string,...} {...}
%D \doifcommonelse {string,...} {string,...} {then ...} {else ...}
%D \stoptyping

\def\p!dodocommoncheck#1%
  {\edef\!!stringb{#1}%
   \ifx\!!stringa\!!stringb
     \donetrue
     \expandafter\quitprevcommalist
   \fi}

\def\p!doifcommonelse#1#2#3#4%
  {\donefalse
   \let\donottest\dontprocesstest
   \def\p!docommoncheck##1%
     {\edef\!!stringa{##1}%
      \def\commalistelement{##1}% no let to stringa
      \processcommalist[#4]\p!dodocommoncheck}%
   \processcommalist[#3]\p!docommoncheck
   \let\donottest\doprocesstest
   \ifdone\expandafter#1\else\expandafter#2\fi}

\def\doifcommonelse
  {\p!doifcommonelse\firstoftwoarguments\secondoftwoarguments}

\def\doifcommon
  {\p!doifcommonelse\firstofoneargument \gobbleoneargument}

\def\doifnotcommon
  {\p!doifcommonelse\gobbleoneargument  \firstofoneargument}

%D \macros
%D   {doifinstringelse, doifincsnameelse}
%D
%D We can check for the presence of a substring in a given
%D sequence of characters.
%D
%D \starttyping
%D \doifinsetelse {substring} {string} {then ...} {else ...}
%D \stoptyping
%D

\long\def\doifinstringelse#1%
  {\edef\@@@instring{#1}% expand #1 here
   \ifx\@@@instring\empty
     \@EA\thirdofthreearguments
   \else
     \@EA\dodoifinstringelse
   \fi}

\long\def\dodoifinstringelse#1%
  {\p!doifinstringelse\@@@instring{#1}%
     \@EA\firstoftwoarguments
   \else
     \@EA\secondoftwoarguments
   \fi}

\def\pp!doifstringinstringelse#1%
  {\if#1@%
     \@EA\secondoftwoarguments
   \else
     \@EA\firstoftwoarguments
   \fi}

\long\def\doifstringinstringelse#1#2%
  {\long\@EA\def\@EA\p!doifstringinstringelse\@EA##\@EA1#1##2##3\war
     {\pp!doifstringinstringelse##2}%
   \@EA\@EA\@EA\p!doifstringinstringelse\@EA#2#1@@\war}

\long\def\doifinstring#1%%
  {\edef\@@@instring{#1}% expand #1 here
   \ifx\@@@instring\empty
     \@EA\gobbletwoarguments
   \else
     \@EA\dodoifinstring
   \fi}

\long\def\dodoifinstring#1%
  {\p!doifinstringelse\@@@instring{#1}%
     \@EA\firstofoneargument
   \else
     \@EA\gobbleoneargument
   \fi}

\long\def\doifnotinstring#1%%
  {\edef\@@@instring{#1}% expand #1 here
   \ifx\@@@instring\empty
     \@EA\gobbletwoarguments
   \else
     \@EA\dodoifnotinstring
   \fi}

\long\def\dodoifnotinstring#1%
  {\p!doifinstringelse\@@@instring{#1}%
     \@EA\gobbleoneargument
   \else
     \@EA\firstofoneargument
   \fi}

\long\def\p!doifinstringelse#1#2% ##2 can be {abc}
  {\long\@EA\def\@EA\pp!doifinstringelse\@EA##\@EA1#1##2##3\war % expand #1 here
     {\csname if\if##2@fals\else tru\fi e\endcsname}%
  %\expanded{\pp!doifinstringelse#2#1@@\noexpand\war}} % expand #2 here
   \expanded{\pp!doifinstringelse#2#1}@@\war} % expand #2 here

\long\def\p!doifincsnameelse#1#2%
  {\long\def\pp!doifincsnameelse##1#1##2##3\war
     {\csname if\if##2@fals\else tru\fi e\endcsname}%
   \@EA\pp!doifincsnameelse#2#1@@\war}

\long\def\doifincsnameelse#1#2%                   % #3#4%
  {\edef\@@@instring{#1}%
   \@EA\p!doifincsnameelse\@EA{\@@@instring}{#2}% % #3\else#4\fi}
     \expandafter\firstoftwoarguments
   \else
     \expandafter\secondoftwoarguments
   \fi}

%D \macros
%D   {doifsamestringselse,doifsamestring,doifnotsamestring}
%D
%D The next comparison macro converts the arguments into
%D expanded strings. This command can be used to compare for
%D instance \type {\jobname} with a name stored in a macro.

\def\@@doifsamestringelse#1#2%
  {\edef\!!stringa{#1}%
   \edef\!!stringb{#2}%
   \convertcommand\!!stringa\to\!!stringa
   \convertcommand\!!stringb\to\!!stringb
   \ifx\!!stringa\!!stringb}

\def\doifsamestringelse#1#2%
  {\@@doifsamestringelse{#1}{#2}%
     \expandafter\firstoftwoarguments
   \else
     \expandafter\secondoftwoarguments
   \fi}

\def\doifsamestring#1#2%
  {\@@doifsamestringelse{#1}{#2}%
     \expandafter\firstofoneargument
   \else
     \expandafter\gobbleoneargument
   \fi}

\def\doifnotsamestring#1#2%
  {\@@doifsamestringelse{#1}{#2}%
     \expandafter\gobbleoneargument
   \else
     \expandafter\firstofoneargument
   \fi}

%D \macros
%D   {doifnumberelse}
%D
%D \starttyping
%D \doifnumberelse {string} {then ...} {else ...}
%D \stoptyping
%D
%D The macro accepts \type{123}, \type{abc}, \type{{}},
%D \type{\getal} and \type{\the\count...}. This macro is a
%D rather dirty one.

\long\def\doifnumberelse#1% does not accept counters
  {\ifcase0\ifcase1#1\or\or\or\or\or\or\or\or\or\else1\fi\space
     \expandafter\secondoftwoarguments
   \else
     \expandafter\firstoftwoarguments
   \fi}

%D \macros
%D   {doifvalue,doifnotvalue,doifelsevalue,
%D    doifnothing,doifsomething,doifelsenothing,
%D    doifvaluenothing,doifvaluesomething,doifelsevaluenothing}
%D
%D These long named \type{\if} commands can be used to access
%D macros (or variables) that are normally accessed by using
%D \type{\getvalue}. Using these alternatives safes us three
%D tokens per call. Anyone familiar with the not||values
%D ones, can derive their meaning from the definitions.

           \def\doifvalue#1{\doif    {\csname#1\endcsname}}
        \def\doifnotvalue#1{\doifnot {\csname#1\endcsname}}
       \def\doifelsevalue#1{\doifelse{\csname#1\endcsname}}

         \def\doifnothing#1{\doif    {#1}{}}
       \def\doifsomething#1{\doifnot {#1}{}}
     \def\doifelsenothing#1{\doifelse{#1}{}}

    \def\doifvaluenothing#1{\doif    {\csname#1\endcsname}{}}
  \def\doifvaluesomething#1{\doifnot {\csname#1\endcsname}{}}
\def\doifelsevaluenothing#1{\doifelse{\csname#1\endcsname}{}}

%D Faster but spoiling inheritance (copying parameters):
%D
%D \starttyping
%D \def\doifelsevaluesomething#1#2#3%
%D   {\expandafter\ifx\csname#1\endcsname\empty#3\else#2\fi}
%D
%D \def\doifvaluesomething#1#2%
%D   {\expandafter\ifx\csname#1\endcsname\empty\else#2\fi}
%D
%D \def\doifvaluenothing#1#2%
%D   {\expandafter\ifx\csname#1\endcsname\empty#2\fi}
%D \stoptyping
%D
%D Slightly more efficient:

    \def\doifnothing{\doif    \empty}
  \def\doifsomething{\doifnot \empty}
\def\doifelsenothing{\doifelse\empty}

%D The somewhat faster alternatives are:

\long\def\doifvalue#1#2%
  {\edef\!!stringa{\csname#1\endcsname}\edef\!!stringb{#2}%
   \ifx\!!stringa\!!stringb
     \expandafter\firstofoneargument
   \else
     \expandafter\gobbleoneargument
   \fi}

\long\def\doifnotvalue#1#2%
  {\edef\!!stringa{\csname#1\endcsname}\edef\!!stringb{#2}%
   \ifx\!!stringa\!!stringb
     \expandafter\gobbleoneargument
   \else
     \expandafter\firstofoneargument
   \fi}

\long\def\doifelsevalue#1#2%
  {\edef\!!stringa{\csname#1\endcsname}\edef\!!stringb{#2}%
   \ifx\!!stringa\!!stringb
     \expandafter\firstoftwoarguments
   \else
     \expandafter\secondoftwoarguments
   \fi}

\long\def\doifnothing#1%
  {\edef\!!stringa{#1}%
   \ifx\!!stringa\empty
     \expandafter\firstofoneargument
   \else
     \expandafter\gobbleoneargument
   \fi}

\long\def\doifsomething#1%
  {\edef\!!stringa{#1}%
   \ifx\!!stringa\empty
     \expandafter\gobbleoneargument
   \else
     \expandafter\firstofoneargument
   \fi}

\long\def\doifelsenothing#1%
  {\edef\!!stringa{#1}%
   \ifx\!!stringa\empty
     \expandafter\firstoftwoarguments
   \else
     \expandafter\secondoftwoarguments
   \fi}

\long\def\doifsomethingelse#1%
  {\edef\!!stringa{#1}%
   \ifx\!!stringa\empty
     \expandafter\secondoftwoarguments
   \else
     \expandafter\firstoftwoarguments
   \fi}

\long\def\doifvaluenothing#1%
  {\edef\!!stringa{\csname#1\endcsname}%
   \ifx\!!stringa\empty
     \expandafter\firstofoneargument
   \else
     \expandafter\gobbleoneargument
   \fi}

\long\def\doifvaluesomething#1%
  {\edef\!!stringa{\csname#1\endcsname}%
   \ifx\!!stringa\empty
     \expandafter\gobbleoneargument
   \else
     \expandafter\firstofoneargument
   \fi}

\long\def\doifelsevaluenothing#1%
  {\edef\!!stringa{\csname#1\endcsname}%
   \ifx\!!stringa\empty
     \expandafter\firstoftwoarguments
   \else
     \expandafter\secondoftwoarguments
   \fi}

%D \macros
%D   {doifemptyelsevalue, doifemptyvalue, doifnotemptyvalue}
%D
%D Also handy:

\def\doifemptyelsevalue#1%
  {\@EA\ifx\csname#1\endcsname\empty
     \expandafter\firstoftwoarguments
   \else
     \expandafter\secondoftwoarguments
   \fi}

\def\doifemptyvalue#1%
  {\@EA\ifx\csname#1\endcsname\empty
     \expandafter\firstofoneargument
   \else
     \expandafter\gobbleoneargument
   \fi}

\def\doifnotemptyvalue#1%
  {\@EA\ifx\csname#1\endcsname\empty
     \expandafter\gobbleoneargument
   \else
     \expandafter\firstofoneargument
   \fi}

%D \macros
%D   {doifallcommonelse}
%D
%D A complete match of two sets can be tested with
%D \type {\doifallcommonelse}, where the first two
%D arguments are sets.

\def\@@doifallcommonelse#1#2#3#4% slow
  {\def\p!docommoncheck##1%
     {\doifnotinset{##1}{#4}\donefalse
      \ifdone\else\expandafter\quitcommalist\fi}%
   \donetrue
   \processcommalist[#3]\p!docommoncheck
   \ifdone\expandafter#1\else\expandafter#2\fi}

\def\doifallcommonelse
  {\@@doifallcommonelse\firstoftwoarguments\secondoftwoarguments}

\def\doifallcommon
  {\@@doifallcommonelse\firstofonearguments\gobbleoneargument}

\def\doifnotallcommon
  {\@@doifallcommonelse\gobbleoneargument\firstofonearguments}

%>> doifs (end) ——————————————————————————————————————————————————— >>
%<< —— Process comma separated lists —————————————————————————————— >>

%D \macros
%D   {processcommalist,processcommacommand,quitcommalist,
%D    processcommalistwithparameters}
%D
%D We've already seen some macros that take care of comma
%D separated lists. Such list can be processed with
%D
%D \starttyping
%D \processcommalist[string,string,...]\commando
%D \stoptyping
%D
%D The user supplied command \type{\commando} receives one
%D argument: the string. This command permits nesting and
%D spaces after commas are skipped. Empty sets are no problem.
%D
%D \startbuffer
%D \def\dosomething#1{(#1)}
%D
%D 1: \processcommalist [\hbox{$a,b,c,d,e,f$}] \dosomething \par
%D 2: \processcommalist [{a,b,c,d,e,f}]        \dosomething \par
%D 3: \processcommalist [{a,b,c},d,e,f]        \dosomething \par
%D 4: \processcommalist [a,b,{c,d,e},f]        \dosomething \par
%D 5: \processcommalist [a{b,c},d,e,f]         \dosomething \par
%D 6: \processcommalist [{a,b}c,d,e,f]         \dosomething \par
%D 7: \processcommalist []                     \dosomething \par
%D 8: \processcommalist [{[}]                  \dosomething \par
%D \stopbuffer
%D
%D \typebuffer
%D
%D Before we show the result, we present the macro's:

\newcount\commalevel

\def\dododoprocesscommaitem
  {\csname\s!next\the\commalevel\endcsname}

\def\dodoprocesscommaitem
  {\ifx\nexttoken\blankspace
     \@EA\redoprocesscommaitem
   \else\ifx\nexttoken]%
     \@EAEAEA\gobbleoneargument
   \else
     \@EAEAEA\dododoprocesscommaitem
   \fi\fi}

\def\doprocesscommaitem
  {\futurelet\nexttoken\dodoprocesscommaitem}

%D Empty arguments are not processed. Empty items (\type{,,})
%D however are treated. We have to check for the special case
%D \type{[{a,b,c}]}.

\def\processcommalist[%
  {\futurelet\nexttoken\docheckcommaitem}

\def\docheckcommaitem
  {\ifx\nexttoken]%
     \expandafter\gobblethreearguments
   \else
     \expandafter\doprocesscommalist
   \fi
   \relax} % this one preserved the next {}

\def\doprocesscommalist#1]#2%
  {\global\advance\commalevel \plusone
   \long\expandafter\def\csname\s!next\the\commalevel\endcsname##1,%
     {#2{##1}\doprocesscommaitem}%
   \@EA\dodoprocesscommaitem\gobbleoneargument#1,]\relax
   \global\advance\commalevel \minusone }

%D One way of quitting a commalist halfway is:

\def\quitcommalist
  {\begingroup\let\doprocesscommaitem\doquitcommalist}

\def\doquitcommalist#1]%
  {\endgroup}

\def\quitprevcommalist
  {\begingroup\let\doprocesscommaitem\doquitprevcommalist}

\def\doquitprevcommalist#1]%
  {\let\doprocesscommaitem\doquitcommalist}

%D The hack we used for checking the next character
%D \type {\doifnextcharelse} is also used here.

\def\:{\redoprocesscommaitem}

\expandafter\def\: {\futurelet\nexttoken\dodoprocesscommaitem}

%D \starttyping
%D \def\first{aap,noot,mies}
%D \def\second{laatste}
%D
%D \processcommacommand[\first]\message
%D \processcommacommand[\first,second,third]\message
%D \processcommacommand[\first,between,\second]\message
%D \stoptyping
%D
%D Commands that are part of the list are expanded, so the
%D use of this macro has its limits.

\def\processcommacommand[#1]%
  {\expanded{\processcommalist[#1]}}

%D The argument to \type{\command} is not delimited. Because
%D we often use \type{[]} as delimiters, we also have:
%D
%D \starttyping
%D \processcommalistwithparameters[string,string,...]\command
%D \stoptyping
%D
%D where \type{\command} looks like:
%D
%D \starttyping
%D \def\command[#1]{... #1 ...}
%D \stoptyping

\def\processcommalistwithparameters[#1]#2%
  {\def\docommand##1{#2[##1]}%
   \processcommalist[#1]\docommand}

%D \macros
%D   {makerawcommalist,
%D    rawdoinsetelse,
%D    rawprocesscommalist,
%D    rawprocessaction}
%D
%D Some of the commands mentioned earlier are effective but
%D slow. When one is desperately in need of faster alternatives
%D and when the conditions are predictable safe, the \type{\raw}
%D alternatives come into focus. A major drawback is that
%D they do not take \type{\c!constants} into account, simply
%D because no expansion is done. This is no problem with
%D \type{\rawprocesscommalist}, because this macro does not
%D compare anything. Expandable macros are permitted as search
%D string.

\def\makerawcommalist[#1]#2% use \processnext ... here
  {\def\domakerawcommalist##1% we don't expand ##1
     {\ifx#2\empty
        \def#2{##1}%
      \else
        \@EA\def\@EA#2\@EA{#2,##1}%
      \fi}%
   \let#2\empty
   \processcommalist[#1]\domakerawcommalist}

\def\rawprocesscommaitem#1,#2% #2 eats up preceding space
  {\if]#1\else
     \csname\s!next\the\commalevel\endcsname{#1}%
     \expandafter\rawprocesscommaitem
   \fi#2}

\def\rawprocesscommalist[#1]#2% accepteert ook [\cs]
  {\global\advance\commalevel \plusone
   \expandafter\let\csname\s!next\the\commalevel\endcsname#2%
   \expandafter\rawprocesscommaitem#1,],% \relax
   \global\advance\commalevel \minusone }

\def\rawprocesscommacommand[#1]% not really needed
  {\expanded{\rawprocesscommalist[#1]}}

\def\@@rawempty{,,}

\long\def\rawdoifinsetelse#1%
  {\edef\@@@instring{,#1,}% expand #1 here
   \ifx\@@@instring\@@rawempty
     \@EA\thirdofthreearguments
   \else
     \@EA\rawdodoifinsetelse
   \fi}

\long\def\rawdodoifinsetelse#1%
  {\p!doifinstringelse\@@@instring{,#1,}%
     \@EA\firstoftwoarguments
   \else
     \@EA\secondoftwoarguments
   \fi}

\long\def\rawdoifinset#1%
  {\edef\@@@instring{,#1,}% expand #1 here
   \ifx\@@@instring\@@rawempty
     \@EA\gobbletwoarguments
   \else
     \@EA\rawdodoifinset
   \fi}

\long\def\rawdodoifinset#1%%
  {\p!doifinstringelse\@@@instring{,#1,}%
     \@EA\firstofoneargument
   \else
     \@EA\gobbleoneargument
   \fi}

%D \macros
%D   {processseparatedlist}
%D
%D Maybe a bit late, but here is a more general version of the
%D \type{\processcommalist} command. This time we don't handle
%D nesting but accept arbitrary seperators.
%D
%D \starttyping
%D \processseparatedlist[list][separator]\command
%D \stoptyping
%D
%D One can think of things like:
%D
%D \starttyping
%D \processseparatedlist[alfa+beta+gamma][+]\message
%D \stoptyping

%D \startbuffer
%D \processseparatedlist[{aap noot}]  [ ]{\def\xxx} \convertcommand\xxx\to\ascii {\tttf\ascii}
%D \processseparatedlist[{aap} {noot}][ ]{\def\xxx} \convertcommand\xxx\to\ascii {\tttf\ascii}
%D \processseparatedlist[aap {noot}]  [ ]{\def\xxx} \convertcommand\xxx\to\ascii {\tttf\ascii}
%D \processseparatedlist[aap noot]    [ ]{\def\xxx} \convertcommand\xxx\to\ascii {\tttf\ascii}
%D \stopbuffer

% testcase Vit Zyka:
%
% \def\Do#1{(#1)}
%    1\processseparatedlist[{aap noot}]  [ ]\Do \par
%    2\processseparatedlist[{aap} {noot}][ ]\Do \par
%    3\processseparatedlist[aap {noot}]  [ ]\Do \par
%    4\processseparatedlist[aap noot]    [ ]\Do \par
%    5\processseparatedlist[aap;noot;a noot;noot a; noot a noot][;]\Do \par
%    6\processseparatedlist[][;]\Do \par
%    7\processseparatedlist[;][;]\Do \par

\def\doprocessseparatedlist#1]#2[#3]#4%
   {\def\dodoprocessseparatedlist##1##2#3%
      {\def\!!stringa{##2}% suggested by VZ
       \if]##1%
         \let\dodoprocessseparatedlist\relax
       \else\ifx\blankspace\!!stringa
         #4{##1}%
       \else\if]##2%
         \let\dodoprocessseparatedlist\relax
       \else
         #4{##1##2}%
       \fi\fi\fi
       \dodoprocessseparatedlist}%
    \@EA\dodoprocessseparatedlist\gobbleoneargument#1#3]#3}

\def\processseparatedlist[%
  {\doprocessseparatedlist\relax}

%D \macros
%D   {processlist}
%D
%D An even more general list processing macro is the
%D following one:
%D
%D \starttyping
%D \processlist{beginsym}{endsym}{separator}\docommand list
%D \stoptyping
%D
%D This one supports arbitrary open and close symbols as well
%D as user defined separators.
%D
%D \starttyping
%D \processlist(){=>}\docommand(a=>b=>c=>d)
%D \stoptyping

\long\def\processlist#1#2#3#4% no blank skipping !
  {\def\doprocesslist##1#2%
     {\def\dodoprocesslist####1####2#3%
        {\ifx#2####1%
           \let\dodoprocesslist\relax
         \else\ifx#2####2%
           \let\dodoprocesslist\relax
         \else
           #4{####1####2}%
         \fi\fi
         \dodoprocesslist}%
      \expandafter\dodoprocesslist\gobbleoneargument##1#3#2#3}%
   \def\dodoprocesslist#1%
     {\doprocesslist\relax}%
   \dodoprocesslist}

%>> Process comma separated lists (end) ——————————————————————————— >>
%<< —— Process action lists (TODO) ———————————————————————————————— >>

%D \macros
%D   {processaction,
%D    processfirstactioninset,
%D    processallactionsinset}
%D
%D \CONTEXT\ makes extensive use of a sort of case or switch
%D command. Depending of the presence of one or more provided
%D items, some actions is taken. These macros can be nested
%D without problems.
%D
%D \starttyping
%D \processaction           [x]     [a=>\a,b=>\b,c=>\c]
%D \processfirstactioninset [x,y,z] [a=>\a,b=>\b,c=>\c]
%D \processallactionsinset  [x,y,z] [a=>\a,b=>\b,c=>\c]
%D \stoptyping
%D
%D We can supply both a \type{default} action and an action
%D to be undertaken when an \type{unknown} value is met:
%D
%D \starttyping
%D \processallactionsinset
%D   [x,y,z]
%D   [      a=>\a,
%D          b=>\b,
%D          c=>\c,
%D    default=>\default,
%D    unknown=>\unknown{... \commalistelement ...}]
%D \stoptyping
%D
%D When \type{#1} is empty, this macro scans list \type{#2} for
%D the keyword \type{default} and executed the related action
%D if present. When \type{#1} is non empty and not in the list,
%D the action related to \type{unknown} is executed. Both
%D keywords must be at the end of list \type{#2}. Afterwards,
%D the actually found keyword is available in
%D \type{\commalistelement}. An advanced example of the use of
%D this macro can be found in \PPCHTEX, where we completely
%D rely on \TEX\ for interpreting user supplied keywords like
%D \type{SB}, \type{SB1..6}, \type{SB125} etc.
%D
%D Even a quick glance at the macros below show some overlap,
%D which means that more efficient alternatives are possible.
%D Because these macro's are very sensitive to subtle changes,
%D we've decided to present the readable originals first
%D Maybe these these macros look complicated, but this is a
%D direct result of the support of nesting. Protection is only
%D applied in \type{\processaction}.
%D
%D \starttyping
%D \newcount\processlevel
%D
%D \def\processaction[#1]#2[#3]%
%D   {\doifelse{#1}{}
%D      {\def\p!compareprocessaction[##1=>##2]%
%D         {\edef\!!stringa{##1}%
%D          \ifx\!!stringa\s!default
%D            \def\commalistelement{#1}%
%D            ##2%
%D          \fi}}
%D      {\let\donottest=\dontprocesstest
%D       \edef\!!stringb{#1}%
%D       \let\donottest=\doprocesstest
%D       \def\p!compareprocessaction[##1=>##2]%
%D         {\edef\!!stringa{##1}%
%D          \ifx\!!stringa\!!stringb
%D            \def\commalistelement{#1}%
%D            ##2%
%D            \let\p!doprocessaction=\gobbleoneargument
%D          \else\ifx\!!stringa\s!unknown
%D            \def\commalistelement{#1}%
%D            ##2%
%D          \fi\fi}}%
%D    \def\p!doprocessaction##1%
%D      {\p!compareprocessaction[##1]}%
%D    \processcommalist[#3]\p!doprocessaction}
%D
%D \def\processfirstactioninset[#1]#2[#3]%
%D   {\doifelse{#1}{}
%D      {\processaction[][#3]}
%D      {\def\p!compareprocessaction[##1=>##2][##3]%
%D         {\edef\!!stringa{##1}%
%D          \edef\!!stringb{##3}%
%D          \ifx\!!stringa\!!stringb
%D            \def\commalistelement{##3}%
%D            ##2%
%D            \let\p!doprocessaction=\gobbleoneargument
%D            \let\p!dodoprocessaction=\gobbleoneargument
%D          \else\ifx\!!stringa\s!unknown
%D            \def\commalistelement{##3}%
%D            ##2%
%D          \fi\fi}%
%D       \def\p!doprocessaction##1%
%D         {\def\p!dodoprocessaction####1%
%D            {\p!compareprocessaction[####1][##1]}%
%D          \processcommalist[#3]\p!dodoprocessaction}%
%D       \processcommalist[#1]\p!doprocessaction}}
%D
%D \def\processallactionsinset[#1]#2[#3]%
%D   {\doifelse{#1}{}
%D      {\processaction[][#3]}
%D      {\advance\processlevel by 1
%D       \def\p!compareprocessaction[##1=>##2][##3]%
%D         {\edef\!!stringa{##1}%
%D          \edef\!!stringb{##3}%
%D          \ifx\!!stringa\!!stringb
%D            \def\commalistelement{##3}%
%D            ##2%
%D            \let\p!dodoprocessaction=\gobbleoneargument
%D          \else\ifx\!!stringa\s!unknown
%D            \def\commalistelement{##3}%
%D            ##2%
%D          \fi\fi}%
%D       \setvalue{\s!do\the\processlevel}##1%
%D         {\def\p!dodoprocessaction####1%
%D            {\p!compareprocessaction[####1][##1]}%
%D          \processcommalist[#3]\p!dodoprocessaction}%
%D       \processcommalist[#1]{\getvalue{\s!do\the\processlevel}}%
%D       \advance\processlevel by -1 }}
%D \stoptyping
%D
%D The gain of speed in the (again) next implementation is
%D around 20\%, depending on the application.

\newcount\processlevel

\def\p!compareprocessactionA[#1=>#2][#3]%
  {\edef\!!stringb{#1}%
   \ifx\!!stringb\s!default
     \let\commalistelement\empty
     #2%
   \fi}

% \def\p!compareprocessactionB[#1=>#2][#3]%
%   {\expandedaction\!!stringb{#1}%
%    \ifx\!!stringa\!!stringb
%      \def\commalistelement{#3}%
%      #2%
%      \let\p!doprocessaction\gobbleoneargument
%    \else
%      \edef\!!stringb{#1}%
%      \ifx\!!stringb\s!unknown
%        \def\commalistelement{#3}% beware of loops
%        #2%
%      \fi
%    \fi}

% met \quitcommalist tot meer dan 25\% sneller

\def\p!compareprocessactionB[#1=>#2][#3]%
  {\expandedaction\!!stringb{#1}%
   \ifx\!!stringa\!!stringb
     \def\commalistelement{#3}%
     #2%
     \expandafter\quitcommalist
   \else
     \edef\!!stringb{#1}%
     \ifx\!!stringb\s!unknown
       \def\commalistelement{#3}% beware of loops
       #2%
     \fi
   \fi}

\beginTEX

\def\processaction[#1]#2[#3]%
  {\let\donottest\dontprocesstest
   \expandedaction\!!stringa{#1}%
   \let\donottest\doprocesstest
   \ifx\!!stringa\empty
     \let\p!compareprocessaction\p!compareprocessactionA
   \else
     \let\p!compareprocessaction\p!compareprocessactionB
   \fi
   \def\p!doprocessaction##1%
     {\p!compareprocessaction[##1][#1]}%
   \processcommalist[#3]\p!doprocessaction
   \expandactions}

\endTEX

\beginETEX \protected

\def\processaction[#1]#2[#3]% faster version follows
  {\expandedaction\!!stringa{#1}%
   \ifx\!!stringa\empty
     \let\p!compareprocessaction\p!compareprocessactionA
   \else
     \let\p!compareprocessaction\p!compareprocessactionB
   \fi
   \def\p!doprocessaction##1%
     {\p!compareprocessaction[##1][#1]}%
   \processcommalist[#3]\p!doprocessaction
   \expandactions}

\endETEX

% \def\p!compareprocessactionC[#1=>#2][#3]%
%   {\expandedaction\!!stringa{#1}%
%    \expandedaction\!!stringb{#3}%
%    \ifx\!!stringa\!!stringb
%      \def\commalistelement{#3}%
%      #2%
%      \let\p!doprocessaction\gobbleoneargument
%      \let\p!dodoprocessaction\gobbleoneargument
%    \else
%      \edef\!!stringa{#1}%
%      \ifx\!!stringa\s!unknown
%        \def\commalistelement{#3}%
%        #2%
%      \fi
%    \fi}

\def\p!compareprocessactionC[#1=>#2][#3]%
  {\expandedaction\!!stringa{#1}%
   \expandedaction\!!stringb{#3}%
   \ifx\!!stringa\!!stringb
     \def\commalistelement{#3}%
     #2%
     \expandafter\quitprevcommalist
   \else
     \edef\!!stringa{#1}%
     \ifx\!!stringa\s!unknown
       \def\commalistelement{#3}%
       #2%
     \fi
   \fi}

\def\processfirstactioninset[#1]#2[#3]% faster version follows
  {\expandedaction\!!stringa{#1}%
   \ifx\!!stringa\empty
     \processaction[][#3]%
   \else
     \def\p!doprocessaction##1%
       {\def\p!dodoprocessaction####1%
          {\p!compareprocessactionC[####1][##1]}%
        \processcommalist[#3]\p!dodoprocessaction}%
     \processcommalist[#1]\p!doprocessaction
   \fi
   \expandactions}

% \def\p!compareprocessactionD[#1=>#2][#3]%
%   {\expandedaction\!!stringa{#1}%
%    \expandedaction\!!stringb{#3}%
%    \ifx\!!stringa\!!stringb
%      \def\commalistelement{#3}%
%      #2%
%      \let\p!dodoprocessaction\gobbleoneargument
%    \else
%      \edef\!!stringa{#1}%
%      \ifx\!!stringa\s!unknown
%        \def\commalistelement{#3}%
%        #2%
%      \fi
%    \fi}

\def\p!compareprocessactionD[#1=>#2][#3]%
  {\expandedaction\!!stringa{#1}%
   \expandedaction\!!stringb{#3}%
   \ifx\!!stringa\!!stringb
     \def\commalistelement{#3}%
     #2%
     \expandafter\quitcommalist
   \else
     \edef\!!stringa{#1}%
     \ifx\!!stringa\s!unknown
       \def\commalistelement{#3}%
       #2%
     \fi
   \fi}

\def\doprocessallactionsinset
  {\csname\s!do\the\processlevel\endcsname}

\def\processallactionsinset[#1]#2[#3]% faster version follows
  {\expandedaction\!!stringa{#1}%
   \ifx\!!stringa\empty
     \processaction[][#3]%
   \else
     \advance\processlevel \plusone
     \expandafter\def\csname\s!do\the\processlevel\endcsname##1%
       {\def\p!dodoprocessaction####1%
          {\p!compareprocessactionD[####1][##1]}%
        \processcommalist[#3]\p!dodoprocessaction}%
     \processcommalist[#1]\doprocessallactionsinset
     \advance\processlevel \minusone
   \fi
   \expandactions}

%D We can speed up these macros a bit when we use a dedicated
%D commalist processor, one that avoids passing the (often)
%D big action list.

\beginTEX

\def\processaction[#1]#2[%
  {\let\donottest\dontprocesstest
   \expandedaction\!!stringa{#1}%
   \let\donottest\doprocesstest
   \ifx\!!stringa\empty
     \let\p!compareprocessaction\p!compareprocessactionA
   \else
     \let\p!compareprocessaction\p!compareprocessactionB
   \fi
   \def\p!doprocessaction##1%
     {\p!compareprocessaction[##1][#1]}%
   \processnextcommalist\relax\expandactions\p!doprocessaction[}

\endTEX

\beginETEX

\def\processaction[#1]#2[%
  {\expandedaction\!!stringa{#1}%
   \ifx\!!stringa\empty
     \let\p!compareprocessaction\p!compareprocessactionA
   \else
     \let\p!compareprocessaction\p!compareprocessactionB
   \fi
   \def\p!doprocessaction##1%
     {\p!compareprocessaction[##1][#1]}%
   \processnextcommalist\relax\expandactions\p!doprocessaction[}

\endETEX

\def\processfirstactionsinset[#1]%
  {\expandedaction\!!stringa{#1}%
   \ifx\!!stringa\empty
     \expandafter\processaction
   \else
     \expandafter\processfirstactionsinsetindeed
   \fi
   [#1]}

\def\processfirstactioninsetindeed[#1]#2[#3]%
  {\def\p!doprocessaction##1%
     {\def\p!dodoprocessaction####1%
        {\p!compareprocessactionC[####1][##1]}%
      \processcommalist[#3]\p!dodoprocessaction}%
   \processcommalist[#1]\p!doprocessaction
   \expandactions}

\def\processallactionsinset[#1]%
  {\expandedaction\!!stringa{#1}%
   \ifx\!!stringa\empty
     \expandafter\processaction
   \else
     \expandafter\processallactionsinsetindeed
   \fi
   [#1]}

\def\processallactionsinsetindeed[#1]#2[#3]%
  {\advance\processlevel \plusone
   \expandafter\def\csname\s!do\the\processlevel\endcsname##1%
     {\def\p!dodoprocessaction####1%
        {\p!compareprocessactionD[####1][##1]}%
      \processcommalist[#3]\p!dodoprocessaction}%
   \processcommalist[#1]\doprocessallactionsinset
   \advance\processlevel \minusone
   \expandactions}

\def\processnextcommalist#1#2#3[#4#5]%
  {#1%
   \let\nexttoken#4%
   \global\advance\commalevel \plusone
   \long\expandafter\def\csname\s!next\the\commalevel\endcsname##1,%
     {#3{##1}\doprocesscommaitem}%
   \dodoprocesscommaitem#4#5,]\relax
   \global\advance\commalevel \minusone
   #2}

%D I do have an even faster version (saving 3 sec on a 13
%D sec run for 50K invocations, but normally we don't have
%D that many calls and that alternative uses more macros and is
%D even less readable. What we did add, was \type {\@EA}, so
%D that we can pass a command.

%D \macros
%D   {unexpandedprocessaction,
%D    unexpandedprocessfirstactioninset,
%D    unexpandedprocessallactionsinset}
%D
%D Now what are those expansion commands doing there. Well,
%D sometimes we want to compare actions that may consist off
%D commands (i.e. are no constants). In such occasions we can
%D use the a bit slower alternatives:

\def\unexpandedprocessfirstactioninset{\dontexpandactions\processfirstactioninset}
\def\unexpandedprocessaction          {\dontexpandactions\processaction}
\def\unexpandedprocessallactionsinset {\dontexpandactions\processallactionsinset}

%D By default we expand actions:

\def\expandactions{\let\expandedaction\edef} \expandactions

%D But when needed we convert the strings to meaningful
%D sequences of characters.

\def\unexpandedaction#1>{}

\def\noexpandedaction#1#2%
  {\def\@@convertedargument{#2}%
   \@EA\edef\@EA#1\@EA{\@EA\unexpandedaction\meaning\@@convertedargument}}

\def\dontexpandactions%
  {\let\expandedaction\noexpandedaction}

%>> Process action lists (end) ———————————————————————————————————— >>
%<< —— Assignments ———————————————————————————————————————————————— >>

%D \macros
%D   {dosetvalue,dosetevalue,dosetgvalue,docopyvalue,doresetvalue,
%D    dogetvalue}
%D
%D \starttyping
%D \dosetvalue   {label}    {variable}   {value}
%D \dosetevalue  {label}    {variable}   {value}
%D \dosetgvalue  {label}    {variable}   {value}
%D \docopyvalue  {to label} {from label} {variable}
%D \doresetvalue {label}    {variable}
%D \stoptyping
%D
%D These macros are in fact auxiliary ones and are not meant
%D for use outside the assignment macros.

\def\dosetvalue#1#2% #3
  {\@EA\def\csname#1#2\endcsname} % {#3}}

\def\dosetevalue#1#2% #3
  {\@EA\edef\csname#1#2\endcsname} % {#3}}

\def\dosetgvalue#1#2% #3
  {\@EA\gdef\csname#1#2\endcsname} % {#3}}

\def\doresetvalue#1#2%
  {\@EA\let\csname#1#2\endcsname\empty}

\def\doignorevalue#1#2#3%
  {\@EA\let\csname#1#2\endcsname\empty}

\def\docopyvalue#1#2#3%
  {\@EA\def\csname#1#3\endcsname{\csname#2#3\endcsname}}

%D \macros
%D   {doassign,undoassign,doassignempty}
%D
%D Assignments are the backbone of \CONTEXT. Abhorred by the
%D concept of style file hacking, we took a considerable effort
%D in building a parameterized system. Unfortunately there is a
%D price to pay in terms of speed. Compared to other packages
%D and taking the functionality of \CONTEXT\ into account, the
%D total size of the format file is still very acceptable. Now
%D how are these assignments done.
%D
%D Assignments can be realized with:
%D
%D \starttyping
%D \doassign[label][variable=value]
%D \undoassign[label][variable=value]
%D \stoptyping
%D
%D and:
%D
%D \starttyping
%D \doassignempty[label][variable=value]
%D \stoptyping
%D
%D Assignments like \type{\doassign} are compatible with:
%D
%D \starttyping
%D \def\labelvariable{value}
%D \stoptyping
%D
%D We do check for the presence of an \type{=} and loudly
%D complain of it's missed. We will redefine this macro later
%D on, when a more advanced message mechanism is implemented.

\newif\iferrorisfatal

\def\waitonfatalerror
  {\iferrorisfatal\wait\fi}

\def\showassignerror#1#2%
  {\writestatus{setup}{missing or ungrouped '=' after '#1' in line #2}%
   \waitonfatalerror}

\def\p!doassign#1[#2][#3=#4=#5]%
  {\ifx\empty#3\else  % and definitely not \ifx#3\empty
     \ifx\relax#5%
       \showassignerror{#3}{\the\inputlineno\space(#2)}%
     \else
       #1{#2}{#3}{#4}%
     \fi
   \fi}

\def\doassign  [#1][#2]{\p!doassign\dosetvalue  [#1][#2==\relax]}
\def\doeassign [#1][#2]{\p!doassign\dosetevalue [#1][#2==\relax]}
\def\undoassign[#1][#2]{\p!doassign\doresetvalue[#1][#2==\relax]}

\def\doassignempty[#1][#2=#3]%
  {\ifundefined{#1#2}\dosetvalue{#1}{#2}{#3}\fi}

%D \macros
%D   {assignifempty}
%D
%D We can assign a default value to an empty macro using:
%D
%D \starttyping
%D \assignifempty \macros {default value}
%D \stoptyping
%D
%D We don't explicitly test if the macro is defined.

\def\assignifempty#1#2% can be sped up
  {\doifsomething{#1}{\def#1{#2}}} % {\doifnot{#1}{}{\def#1{#2}}}

%D \macros
%D   {processassignmentlist,processassignmentcommand,
%D    startprocessassignmentlist,startprocessassignmentcommand}

\def\processassignmentlist[#1]#2% #2 == \command{key}{value]
  {\def\doprocessassignmententry##1{#2}% {##2}{##3} % namespace is ignored
   \dogetparameters\doprocessassignmententry[][#1]}

\def\processassignmentcommand[#1]%
  {\normalexpanded{\noexpand\processassignmentlist[#1]}}

\long\def\startprocessassignmentlist[#1]#2\stopprocessassignmentlist
  {\long\def\currentassignmentlistcommand##1##2{\def\currentassignmentlistkey{##1}\def\currentassignmentlistvalue{##2}#2}%
   \processassignmentlist[#1]\currentassignmentlistcommand}

\long\def\startprocessassignmentcommand[#1]#2\stopprocessassignmentcommand
  {\long\def\currentassignmentlistcommand##1##2{\def\currentassignmentlistkey{##1}\def\currentassignmentlistvalue{##2}#2}%
   \normalexpanded{\noexpand\processassignmentlist[#1]}\currentassignmentlistcommand}

%D \macros
%D   {doifassignmentelse}
%D
%D A lot of \CONTEXT\ commands take optional arguments, for
%D instance:
%D
%D \starttyping
%D \dothisorthat[alfa,beta]
%D \dothisorthat[first=foo,second=bar]
%D \dothisorthat[alfa,beta][first=foo,second=bar]
%D \stoptyping
%D
%D Although a combined solution is possible, we prefer a
%D seperation. The next command takes care of propper
%D handling of such multi||faced commands.
%D
%D \starttyping
%D \doifassignmentelse {...} {then ...} {else ...}
%D \stoptyping

\def\doifassignmentelse#1%
  {\convertargument#1\to\ascii
   \doifinstringelse=\ascii}

%>> Assignments (end) ————————————————————————————————————————————— >>
%<< —— Parameters ————————————————————————————————————————————————— >>

%D \macros
%D   {getparameters,geteparameters,getgparameters,
%D    forgetparameters}
%D
%D Using the assignment commands directly is not our
%D ideal of user friendly interfacing, so we take some further
%D steps.
%D
%D \starttyping
%D \getparameters    [label] [...=...,...=...]
% %D \forgetparameters [label] [...=...,...=...]
%D \stoptyping

\def\dogetparameters#1[#2]#3[#4]%
  {\def\p!dogetparameter##1%
     {\p!doassign#1[#2][##1==\relax]}%
   \processcommalist[#4]\p!dogetparameter}

\def\getparameters   {\dogetparameters\dosetvalue}
\def\geteparameters  {\dogetparameters\dosetevalue}
\def\getgparameters  {\dogetparameters\dosetgvalue}
\def\forgetparameters{\dogetparameters\doignorevalue}

\let\getexpandedparameters=\geteparameters

%D This one is slightly faster:

\def\dogetparameters#1[#2]#3[#4%
  {\if\noexpand#4]%
     \expandafter\gobbleoneargument
   \else
     \def\p!dogetparameter##1{\p!doassign#1[#2][##1==\relax]}%
     \expandafter\xdogetparameters
   \fi#4}

\def\xdogetparameters#1]%
  {\processcommalist[#1]\p!dogetparameter}

%D The next alternative is much faster but also uglier. Because
%D in \XML\ processing we will probably set much more parameters
%D than normally we need this faster one.

\def\dogetparameters#1[#2]#3[#4%
  {\if\noexpand#4]%
     \expandafter\gobbleoneargument
   \else
     \def\p!dogetparameter{\p!doassign#1#2}%
     \expandafter\xdogetparameters
   \fi#4}

\def\xdogetparameters#1]%
  {\xprocesscommaitem#1,],\@relax@}

\long\def\xprocesscommaitem#1,#2% #2 takes space before ,
  {\if,#1,% dirty trick for testing #1=empty
     \@EA\xprocesscommaitem
   \else\if]#1%
     \@EAEAEA\gobbleoneargument
   \else
     \p!dogetparameter\@relax@#1==\empty\@relax@
     \@EAEAEA\xprocesscommaitem
   \fi\fi#2}

%D Here we use a slightly different assignment macro:

\def\p!doassign#1#2\@relax@#3=#4=#5#6\@relax@
  {\ifx#5\empty
     \@EA\xshowassignerror
   \else\ifx#5=%
     \@EAEAEA#1%
   \else
     \@EAEAEA\xshowassignerror
   \fi\fi
   {#2}{#3}{#4}}

\def\xshowassignerror#1#2#3%
  {\showassignerror{#2}{\the\inputlineno\space(#1)}}

\def\doassign  [#1][#2]{\p!doassign\dosetvalue  #1\@relax@#2==\empty\@relax@}
\def\doeassign [#1][#2]{\p!doassign\dosetevalue #1\@relax@#2==\empty\@relax@}
\def\undoassign[#1][#2]{\p!doassign\doresetvalue#1\@relax@#2==\empty\@relax@}

%D \macros{currentvalue}
%D
%D Just in case a \type{\getparameter} argument itself ends up
%D inside a \type{\write} or other expandable location, our
%D new macro needs a default value.

\let\currentvalue\empty

\def\p!n!doassign#1#2\@relax@#3=#4=#5#6\@relax@
  {\ifx\empty#3\empty
     \@EA\xshowassignerror
   \else\ifx#5\empty
     \@EAEAEA\xshowassignerror
   \else
     \@EAEAEA#1%
   \fi\fi
   {#2}{#3}{#4}}

\def\p!e!doassign#1#2\@relax@#3=#4=#5#6\@relax@
  {\ifx\empty#3\empty
     \@EA\xshowassignerror
   \else\ifx#5\empty
     \@EAEAEA\xshowassignerror
   \else
     \@EA\ifx\csname#2#3\endcsname\relax
       \let\currentvalue\empty
     \else
       \@EA\let\@EA\currentvalue\csname#2#3\endcsname
     \fi
     \@EAEAEA#1%
   \fi\fi
   {#2}{#3}{#4}}

\let\p!doassign\p!n!doassign

\let\currentvalue\empty

%D \macros {expandparameters}
%D
%D Example usage:
%D
%D \startbuffer
%D \getparameters[taco][name=taco]
%D \convertcommand\taconame\to\ascii \ascii
%D \expandparameters \getparameters[taco][name=\currentvalue\space hoekwater]
%D \convertcommand\taconame\to\ascii \ascii
%D \getparameters[taco][name=\currentvalue\space hoekwater]
%D \convertcommand\taconame\to\ascii \ascii
%D \stopbuffer
%D
%D \typebuffer
%D \startlines
%D \getbuffer
%D \stoplines

%D Here we hook in the code (beware, this is the optimized get **):

\def\xdoget@n@parameters#1]%
  {\xprocesscommaitem#1,],\@relax@}

\def\xdoget@e@parameters#1]%
  {\let\dosetnvalue\dosetvalue
   \let\dosetvalue\dosetevalue
   \let\p!doassign\p!e!doassign
   \xprocesscommaitem#1,],\@relax@
   \let\p!doassign\p!n!doassign
   \let\dosetvalue\dosetnvalue
   \let\xdogetparameters\xdoget@n@parameters
   \let\currentvalue\empty}

\let\xdogetparameters\xdoget@n@parameters % **

\def\expandparameters{\let\xdogetparameters\xdoget@e@parameters}

%D \macros
%D   {getemptyparameters}
%D
%D Sometimes we explicitly want variables to default to an
%D empty string, so we welcome:
%D
%D \starttyping
%D \getemptyparameters [label] [...=...,...=...]
%D \stoptyping

\def\getemptyparameters[#1]#2[#3]%
  {\def\p!dogetemptyparameter##1%
     {\doassignempty[#1][##1]}%
   \processcommalist[#3]\p!dogetemptyparameter}

%D \macros
%D   {copyparameters}
%D
%D \starttyping
%D \copyparameters
%D   [internal][external]
%D   [alfa,beta]
%D \stoptyping
%D
%D \starttyping
%D \def\internalalfa {\externalalfa}
%D \def\internalbeta {\externalbeta}
%D \stoptyping

\def\copyparameters[#1]#2[#3]#4[#5]%
  {\doifnot{#1}{#3}
     {\def\docopyparameter{\docopyvalue{#1}{#3}}%
      \processcommalist[#5]\docopyparameter}}

%D \macros
%D   {ifparameters,checkparameters}
%D
%D A slightly different one is \type{\checkparameters}, which
%D also checks on the presence of a~\type{=}.
%D
%D The boolean \type{\ifparameters} can be used afterwards.
%D Combining both in one \type{\if}||macro would lead to
%D problems with nested \type{\if}'s.
%D
%D \starttyping
%D \checkparameters[argument]
%D \stoptyping

\newif\ifparameters

\def\p!checkparameters#1=#2#3\war%
  {\if#2@\parametersfalse\else\parameterstrue\fi}

\def\checkparameters[#1]%
  {\p!checkparameters#1=@@\war}

\def\dosetrawvalue #1#2#3{\@EA \def\csname#1#2\endcsname{#3}}
\def\dosetrawevalue#1#2#3{\@EA\edef\csname#1#2\endcsname{#3}}
\def\dosetrawgvalue#1#2#3{\@EA\gdef\csname#1#2\endcsname{#3}}
\def\dosetrawxvalue#1#2#3{\@EA\xdef\csname#1#2\endcsname{#3}}

\def\getrawparameters      {\dogetparameters\dosetrawvalue }
\def\getraweparameters     {\dogetparameters\dosetrawevalue}
\def\getrawgparameters     {\dogetparameters\dosetrawgvalue}
\def\getrawxparameters     {\dogetparameters\dosetrawxvalue}

\def\globalgetrawparameters{\dogetparameters\dosetrawgvalue} % obsolete


%>> Parameters (end) —————————————————————————————————————————————— >>
%<< —— Arguments handling ————————————————————————————————————————— >>

%D \macros
%D   {dosingleargument,dodoubleargument,dotripleargument,
%D    doquadrupleargument,doquintupleargument,dosixtupleargument,
%D    doseventupleargument}
%D
%D When working with delimited arguments, spaces and
%D lineendings can interfere. The next set of macros uses
%D \TEX' internal scanner for grabbing everything between
%D arguments. Forgive me the funny names.

\def\dosingleargument    {\chardef\expectedarguments 1 \dosingleempty    }
\def\dodoubleargument    {\chardef\expectedarguments 2 \dodoubleempty    }
\def\dotripleargument    {\chardef\expectedarguments 3 \dotripleempty    }
\def\doquadrupleargument {\chardef\expectedarguments 4 \doquadrupleempty }
\def\doquintupleargument {\chardef\expectedarguments 5 \doquintupleempty }
\def\dosixtupleargument  {\chardef\expectedarguments 6 \dosixtupleempty  }
\def\doseventupleargument{\chardef\expectedarguments 7 \doseventupleempty}

%D \macros
%D   {iffirstagument,ifsecondargument,ifthirdargument,
%D    iffourthargument,iffifthargument,ifsixthargument,
%D    ifseventhargument}
%D
%D We use some signals for telling the calling macros if all
%D wanted arguments are indeed supplied by the user.

\newif\iffirstargument
\newif\ifsecondargument
\newif\ifthirdargument
\newif\iffourthargument
\newif\iffifthargument
\newif\ifsixthargument
\newif\ifseventhargument

%D \macros
%D   {dosingleempty,dodoubleempty,dotripleempty,
%D    doquadrupleempty,doquintupleempty,dosixtupeempty,
%D    doseventupleempty}
%D
%D The empty argument supplying macros mentioned before, look
%D like:
%D
%D \starttyping
%D \dosingleempty    \command
%D \dodoubleempty    \command
%D \dotripleempty    \command
%D \doquadrupleempty \command
%D \doquintupleempty \command
%D \dosixtupleempty  \command
%D \doseventupleempty\command
%D \stoptyping
%D
%D So \type{\dodoubleempty} leades to:
%D
%D \starttyping
%D \command[#1][#2]
%D \command[#1][]
%D \command[][]
%D \stoptyping
%D
%D Depending of the generousity of the user. Afterwards one can
%D use the \type{\if...argument} boolean. For novice: watch
%D the stepwise doubling of \type{#}'s

% idea: \ignorespaces afterwards

\chardef\noexpectedarguments=0
\chardef\expectedarguments  =0

\def\showargumenterror#1#2%
  {\writestatus{systems}{#1 argument(s) expected in line #2}}

\def\doshowargumenterror
  {\ifnum\expectedarguments>\noexpectedarguments
     \showargumenterror{\number\expectedarguments}{\number\inputlineno}%
   \fi
   \noshowargumenterror}

\def\noshowargumenterror
  {\let\expectedarguments\noexpectedarguments}

\long\def\dogetargument#1#2#3#4%
  {\let\charactertoken=#1%
   \def\!!stringa{\noshowargumenterror#3\dodogetargument}%
   \def\!!stringb{\doshowargumenterror#4\dodogetargument#1#2}%
   \futurelet\nexttoken\inspectnextcharacter}

\def\getsingleempty#1#2#3%
  {\def\dodogetargument%
     {#3}%
   \dogetargument#1#2\firstargumenttrue\firstargumentfalse}

\def\getdoubleempty#1#2#3%
  {\def\dodogetargument#1##1#2%
     {\def\dodogetargument%
        {#3#1{##1}#2}%
      \dogetargument#1#2\secondargumenttrue\secondargumentfalse}%
   \dogetargument#1#2\firstargumenttrue\firstargumentfalse}

\def\gettripleempty#1#2#3%
  {\def\dodogetargument#1##1#2%
     {\def\dodogetargument#1####1#2%
        {\def\dodogetargument%
           {#3#1{##1}#2%
              #1{####1}#2}%
         \dogetargument#1#2\thirdargumenttrue\thirdargumentfalse}%
      \dogetargument#1#2\secondargumenttrue\secondargumentfalse}%
   \dogetargument#1#2\firstargumenttrue\firstargumentfalse}

\def\getquadrupleempty#1#2#3%
  {\def\dodogetargument#1##1#2%
     {\def\dodogetargument#1####1#2%
        {\def\dodogetargument#1########1#2%
           {\def\dodogetargument%
              {#3#1{##1}#2%
                 #1{####1}#2%
                 #1{########1}#2}%
            \dogetargument#1#2\fourthargumenttrue\fourthargumentfalse}%
         \dogetargument#1#2\thirdargumenttrue\thirdargumentfalse}%
      \dogetargument#1#2\secondargumenttrue\secondargumentfalse}%
   \dogetargument#1#2\firstargumenttrue\firstargumentfalse}

\def\getquintupleempty#1#2#3%
  {\def\dodogetargument#1##1#2%
     {\def\dodogetargument#1####1#2%
        {\def\dodogetargument#1########1#2%
           {\def\dodogetargument#1################1#2%
              {\def\dodogetargument%
                 {#3#1{##1}#2%
                    #1{####1}#2%
                    #1{########1}#2%
                    #1{################1}#2}%
               \dogetargument#1#2\fifthargumenttrue\fifthargumentfalse}%
            \dogetargument#1#2\fourthargumenttrue\fourthargumentfalse}%
         \dogetargument#1#2\thirdargumenttrue\thirdargumentfalse}%
      \dogetargument#1#2\secondargumenttrue\secondargumentfalse}%
   \dogetargument#1#2\firstargumenttrue\firstargumentfalse}

\def\getsixtupleempty#1#2#3%
  {\def\dodogetargument#1##1#2%
     {\def\dodogetargument#1####1#2%
        {\def\dodogetargument#1########1#2%
           {\def\dodogetargument#1################1#2%
              {\def\dodogetargument#1################################1#2%
                 {\def\dodogetargument%
                    {#3#1{##1}#2%
                       #1{####1}#2%
                       #1{########1}#2%
                       #1{################1}#2%
                       #1{################################1}#2}%
                 \dogetargument#1#2\sixthargumenttrue\sixthargumentfalse}%
               \dogetargument#1#2\fifthargumenttrue\fifthargumentfalse}%
            \dogetargument#1#2\fourthargumenttrue\fourthargumentfalse}%
         \dogetargument#1#2\thirdargumenttrue\thirdargumentfalse}%
      \dogetargument#1#2\secondargumenttrue\secondargumentfalse}%
   \dogetargument#1#2\firstargumenttrue\firstargumentfalse}

\def\getseventupleempty#1#2#3%
  {\def\dodogetargument#1##1#2%
     {\def\dodogetargument#1####1#2%
        {\def\dodogetargument#1########1#2%
           {\def\dodogetargument#1################1#2%
              {\def\dodogetargument#1################################1#2%
                 {\def\dodogetargument#1################################%
                                        ################################1#2%
                    {\def\dodogetargument%
                       {#3#1{##1}#2%
                          #1{####1}#2%
                          #1{########1}#2%
                          #1{################1}#2%
                          #1{################################1}#2%
                          #1{################################%
                             ################################1}#2}%
                   \dogetargument#1#2\seventhargumenttrue\seventhargumentfalse}%
                 \dogetargument#1#2\sixthargumenttrue\sixthargumentfalse}%
               \dogetargument#1#2\fifthargumenttrue\fifthargumentfalse}%
            \dogetargument#1#2\fourthargumenttrue\fourthargumentfalse}%
         \dogetargument#1#2\thirdargumenttrue\thirdargumentfalse}%
      \dogetargument#1#2\secondargumenttrue\secondargumentfalse}%
   \dogetargument#1#2\firstargumenttrue\firstargumentfalse}

\def\dosingleempty    {\getsingleempty    []}
\def\dodoubleempty    {\getdoubleempty    []}
\def\dotripleempty    {\gettripleempty    []}
\def\doquadrupleempty {\getquadrupleempty []}
\def\doquintupleempty {\getquintupleempty []}
\def\dosixtupleempty  {\getsixtupleempty  []}
\def\doseventupleempty{\getseventupleempty[]}

%D Because some of these are called quite often, we will now
%D replace the more general version by alternatives tuned for
%D speed.

\def\dosingleempty#1%
  {\noshowargumenterror % \relax % prevents lookahead, brr
   \doifnextoptionalelse
     {\firstargumenttrue#1}
     {\dosinglefakeempty#1}}

\def\dodoubleempty#1%
  {\noshowargumenterror % \relax % prevents lookahead, brr
   \doifnextoptionalelse
     {\dodoubletestempty#1}
     {\dodoublefakeempty#1}}

\def\dotripleempty#1%
  {\noshowargumenterror % \relax % prevents lookahead, brr
   \doifnextoptionalelse
     {\dotripletestempty#1}
     {\dotriplefakeempty#1}}

\def\dosinglefakeempty#1%
  {\firstargumentfalse#1[]}

\def\dodoublefakeempty#1%
  {\firstargumentfalse\secondargumentfalse#1[][]}

\def\dotriplefakeempty#1%
  {\firstargumentfalse\secondargumentfalse\thirdargumentfalse#1[][][]}

\long\def\dodoubletestempty#1[#2]%
  {\firstargumenttrue
   \doifnextoptionalelse
     {\secondargumenttrue #1[{#2}]}
     {\secondargumentfalse#1[{#2}][]}}

\long\def\dotripletestempty#1[#2]%
  {\firstargumenttrue
   \doifnextoptionalelse
     {\dotripletestemptyx #1[{#2}]}
     {\secondargumentfalse
      \thirdargumentfalse #1[{#2}][][]}}

\long\def\dotripletestemptyx#1[#2][#3]%
  {\secondargumenttrue
   \doifnextoptionalelse
     {\thirdargumenttrue #1[{#2}][{#3}]}
     {\thirdargumentfalse#1[{#2}][{#3}][]}}

%D \macros
%D   {dosinglegroupempty,dodoublegroupempty,dotriplegroupempty,
%D    doquadruplegroupempty, doquintuplegroupempty}
%D
%D We've already seen some commands that take care of
%D optional arguments between \type{[]}. The next two commands
%D handle the ones with \type{{}}. They are called as:
%D
%D \starttyping
%D \dosinglegroupempty    \ineedONEargument
%D \dodoublegroupempty    \ineedTWOarguments
%D \dotriplegroupempty    \ineedTHREEarguments
%D \doquadruplegroupempty \ineedFOURarguments
%D \doquintuplegroupempty \ineedFIVEarguments
%D \stoptyping

\newtoks \everyrobusttest

\everyrobusttest
  {\let\if         \relax
   \let\ifcat      \relax
   \let\ifnum      \relax
   \let\ifdim      \relax
   \let\ifodd      \relax
   \let\ifvmode    \relax
   \let\ifhmode    \relax
   \let\ifmmode    \relax
   \let\ifinner    \relax
   \let\ifvoid     \relax
   \let\ifhbox     \relax
   \let\ifvbox     \relax
   \let\ifx        \relax
   \let\ifeof      \relax
   \let\iftrue     \relax
   \let\iffalse    \relax
   \let\ifcase     \relax
   \let\ifdefined  \relax
   \let\ifcsname   \relax
   \let\iffontchar \relax
   \let\ifincsname \relax
   \let\ifprimitive\relax
   \let\ifabsnum   \relax
   \let\ifabsdim   \relax
   \let\else       \relax
   \let\or         \relax
   \let\fi         \relax}

\def\beginrobusttest
  {\begingroup
   \the\everyrobusttest}

\let\endrobusttest\endgroup

%D We can add additional definitions later when we have defined
%D \type {\appendtoks}.

\def    \permitspacesbetweengroups{\chardef\@@permitspacesbetweengroups=0 }
\def\dontpermitspacesbetweengroups{\chardef\@@permitspacesbetweengroups=1 }

\dontpermitspacesbetweengroups

\let\normalifx\ifx
\let\normalelse\else
\def\dodogetgroupargument
  {\normalifx\nextargument\bgroup
     \endrobusttest
     \noshowargumenterror
     \def\nextargument{\dogroupargumentyes\dodogetargument}%
   \normalelse
     \normalifcase\@@permitspacesbetweengroups
       \normalifx\nextargument\lineending
         \endrobusttest
         \def\nextargument{\begingroup\def\\ {\endgroup\dogetgroupargument\dogroupargumentyes\dogroupargumentnop}\\}%
       \normalelse\normalifx\nextargument\blankspace
         \endrobusttest
         \def\nextargument{\begingroup\def\\ {\endgroup\dogetgroupargument\dogroupargumentyes\dogroupargumentnop}\\}%
       \normalelse
         \endrobusttest
         \doshowargumenterror
         \def\nextargument{\dogroupargumentnop\dodogetargument{}}%
       \normalfi\normalfi
     \normalelse
       \endrobusttest
       \doshowargumenterror
       \def\nextargument{\dogroupargumentnop\dodogetargument{}}%
     \normalfi
   \normalfi
   \nextargument}%

\def\dogetgroupargument#1#2%
  {\let\dogroupargumentyes#1%
   \let\dogroupargumentnop#2%
   \beginrobusttest\futurelet\nextargument\dodogetgroupargument}

\def\dosinglegroupempty#1%
  {\def\dodogetargument%
     {\dontpermitspacesbetweengroups
      #1}%
   \dogetgroupargument\firstargumenttrue\firstargumentfalse}

\def\dodoublegroupempty#1%
  {\def\dodogetargument##1%
     {\def\dodogetargument%
        {\dontpermitspacesbetweengroups
         #1{##1}}%
      \dogetgroupargument\secondargumenttrue\secondargumentfalse}%
   \dogetgroupargument\firstargumenttrue\firstargumentfalse}

\def\dotriplegroupempty#1%
  {\def\dodogetargument##1%
     {\def\dodogetargument####1%
        {\def\dodogetargument%
           {\dontpermitspacesbetweengroups
            #1{##1}{####1}}%
         \dogetgroupargument\thirdargumenttrue\thirdargumentfalse}%
      \dogetgroupargument\secondargumenttrue\secondargumentfalse}%
   \dogetgroupargument\firstargumenttrue\firstargumentfalse}

\def\doquadruplegroupempty#1%
  {\def\dodogetargument##1%
     {\def\dodogetargument####1%
        {\def\dodogetargument########1%
           {\def\dodogetargument%
              {\dontpermitspacesbetweengroups
               #1{##1}{####1}{########1}}%
            \dogetgroupargument\fourthargumenttrue\fourthargumentfalse}%
         \dogetgroupargument\thirdargumenttrue\thirdargumentfalse}%
      \dogetgroupargument\secondargumenttrue\secondargumentfalse}%
   \dogetgroupargument\firstargumenttrue\firstargumentfalse}

\def\doquintuplegroupempty#1%
  {\def\dodogetargument##1%
     {\def\dodogetargument####1%
        {\def\dodogetargument########1%
           {\def\dodogetargument################1%
             {\def\dodogetargument%
                {\dontpermitspacesbetweengroups
                 #1{##1}{####1}{########1}{################1}}%
              \dogetgroupargument\fifthargumenttrue\fifthargumentfalse}%
            \dogetgroupargument\fourthargumenttrue\fourthargumentfalse}%
         \dogetgroupargument\thirdargumenttrue\thirdargumentfalse}%
      \dogetgroupargument\secondargumenttrue\secondargumentfalse}%
   \dogetgroupargument\firstargumenttrue\firstargumentfalse}

%D These macros can explictly take care of spaces, which means
%D that the next definition and calls are valid:
%D
%D \starttyping
%D \def\test#1#2#3{[#1#2#3]}
%D
%D \dotriplegroupempty\test {a}{b}{c}
%D \dotriplegroupempty\test {a}{b}
%D \dotriplegroupempty\test {a}
%D \dotriplegroupempty\test
%D \dotriplegroupempty\test {a} {b} {c}
%D \dotriplegroupempty\test {a} {b}
%D \dotriplegroupempty\test
%D   {a}
%D   {b}
%D \stoptyping
%D
%D And alike.

%D \macros
%D   {firstofoneargument, firstoftwoarguments, firstofthreearguments
%D    secondoftwoarguments, secondofthreearguments,
%D    thirdofthreearguments}
%D
%D The next six macros (dedicated to Taco) can conveniently
%D used to select arguments. Their names explain their
%D functionality.

\long\def\firstofoneargument#1{#1}

\long\def\firstoftwoarguments #1#2{#1}
\long\def\secondoftwoarguments#1#2{#2}

\long\def\firstofthreearguments #1#2#3{#1}
\long\def\secondofthreearguments#1#2#3{#2}
\long\def\thirdofthreearguments #1#2#3{#3}

\long\def\firstoffourarguments #1#2#3#4{#1}
\long\def\secondoffourarguments#1#2#3#4{#2}
\long\def\thirdoffourarguments #1#2#3#4{#3}
\long\def\fourthoffourarguments#1#2#3#4{#4}

\long\def\firstoffivearguments #1#2#3#4#5{#1}
\long\def\secondoffivearguments#1#2#3#4#5{#2}
\long\def\thirdoffivearguments #1#2#3#4#5{#3}
\long\def\fourthoffivearguments#1#2#3#4#5{#4}
\long\def\fifthoffivearguments #1#2#3#4#5{#5}

\long\def\firstofsixarguments #1#2#3#4#5#6{#1}
\long\def\secondofsixarguments#1#2#3#4#5#6{#2}
\long\def\thirdofsixarguments #1#2#3#4#5#6{#3}
\long\def\fourthofsixarguments#1#2#3#4#5#6{#4}
\long\def\fifthofsixarguments #1#2#3#4#5#6{#5}
\long\def\sixthofsixarguments #1#2#3#4#5#6{#6}

%D \macros
%D   {rawgetparameters}
%D
%D A raw and dirty alternative for \type {\getparameters}; no
%D checking is done!

% \def\rawgetparameters[#1][#2]% scheelt 5\%
%   {\def\rawparameterprefix{#1}%
%    \expandafter\rawsetparameter#2,]=,}

\def\rawsetparameter#1=#2,%
  {\if]#1\else
     \expandafter\def\csname\rawparameterprefix#1\endcsname{#2}%
     \expandafter\rawsetparameter
   \fi}

% the next one handles empty #1 okay:

\def\rawgetparameters[#1][#2% some 5-10% faster
  {\ifx#2]% test is needed, else bomb on [#1][]
     \expandafter\gobbleoneargument
   \else
     \def\rawparameterprefix{#1}%
     \expandafter\dorawgetparameters
   \fi#2}

\def\dorawgetparameters#1]%
  {\expandafter\rawsetparameter#1,]=,}

%D \macros
%D   {dowithpargument,dowithwargument}
%D
%D We start with a commands that acts on paragraphs. This
%D command is called as:
%D
%D \starttyping
%D \dowithpargument\command
%D \dowithpargument{\command ... }
%D \stoptyping
%D
%D \starttyping
%D \command{...}
%D \command ... \par
%D \command
%D   {...}
%D \command
%D   ... \par
%D \stoptyping

\def\dowithpargument#1%
  {\def\nextpar##1 \par{#1{##1}}%
   \def\nextarg##1{#1{##1}}%
   \doifnextbgroupelse\nextarg{\doifnextcharelse\par{#1{}}\nextpar}}

%D The \type{p} in the previous command stands for paragraph.
%D When we want to act upon words we can use the \type{w}
%D alternative.
%D
%D \starttyping
%D \dowithwargument\command
%D \dowithwargument{... \command ...}
%D \stoptyping
%D
%D The main difference bwteen two alternatives is in the
%D handling of \type{\par}'s. This time the space token acts
%D as a delimiter.
%D
%D \starttyping
%D \command{...}
%D \command ...
%D \command
%D   {...}
%D \command
%D   ...
%D \stoptyping

\def\dowithwargument#1%
  {\def\nextwar##1 {#1{##1}}%
   \def\nextarg##1{#1{##1}}%
   \doifnextbgroupelse\nextarg\nextwar}

%D \macros
%D   {dosingleargumentwithset,
%D    dodoubleargumentwithset,dodoubleemptywithset,
%D    dotripleargumentwithset,dotripleemptywithset}
%D
%D These maybe too mysterious macros enable us to handle more
%D than one setup at once.
%D
%D \starttyping
%D \dosingleargumentwithset \command[#1]
%D \dodoubleargumentwithset \command[#1][#2]
%D \dotripleargumentwithset \command[#1][#2][#3]
%D \dodoubleemptywithset    \command[#1][#2]
%D \dotripleemptywithset    \command[#1][#2][#3]
%D \stoptyping
%D
%D The first macro calls \type{\command[##1]} for each string
%D in the set~\type{#1}. The second one calls for
%D \type{\commando[##1][#2]} and the third, well one may guess.
%D These commands support constructions like:
%D
%D \starttyping
%D \def\dodefinesomething[#1][#2]%
%D   {\getparameters[\??xx#1][#2]}
%D
%D \def\definesomething%
%D   {\dodoubleargumentwithset\dodefinesomething}
%D \stoptyping
%D
%D Which accepts calls like:
%D
%D \starttyping
%D \definesomething[alfa,beta,...][variable=...,...]
%D \stoptyping
%D
%D Now a whole bunch of variables like \type{\@@xxalfavariable}
%D and \type{\@@xxbetavariable} is defined.

\def\dodoublewithset#1#2%
  {\def\dododoublewithset[##1][##2]%
     {\doifsomething{##1}
        {\def\dodododoublewithset####1{#2[####1][##2]}%
         \processcommalist[##1]\dodododoublewithset}}%
   #1\dododoublewithset}

\def\dodoubleemptywithset   {\dodoublewithset\dodoubleempty}
\def\dodoubleargumentwithset{\dodoublewithset\dodoubleargument}

\def\dotriplewithset#1#2%
  {\def\dodotriplewithset[##1][##2][##3]%
     {\doifsomething{##1}
        {\def\dododotriplewithset####1{#2[####1][##2][##3]}%
         \processcommalist[##1]\dododotriplewithset}}%
   #1\dodotriplewithset}

\def\dotripleemptywithset   {\dotriplewithset\dotripleempty}
\def\dotripleargumentwithset{\dotriplewithset\dotripleargument}

%>> Arguments handling (end) —————————————————————————————————————— >>
%<< —— New \newif and globals ————————————————————————————————————— >>

%D \macros
%D   {doglobal,
%D    redoglobal,dodoglobal,resetglobal}
%D
%D The two macros \type {\redoglobal} and \type{\dodoglobal} are
%D used in this and some other modules to enforce a user
%D specified \type {\doglobal} action. The last and often only
%D global assignment in a macro is done with
%D \type {\dodoglobal}, but all preceding ones with
%D \type {\redoglobal}. When using only alternatives, one can
%D reset this mechanism with \type {\resetglobal}.

\def\doglobal
  {\let\redoglobal\global
   \def\dodoglobal{\resetglobal\global}}

\def\resetglobal
  {\let\redoglobal\relax
   \let\dodoglobal\relax}

\resetglobal

%D New:

\def\doglobal
  {\ifx\redoglobal\relax
     \let\redoglobal\global
     \let\dodoglobal\@@dodoglobal
  %\else
  %  \writestatus{system}{global not reset, warn me!}%
   \fi}

\def\@@dodoglobal
  {\resetglobal\global}

\def\saveglobal
  {\let\@@dodoglobal\dodoglobal
   \let\@@redoglobal\redoglobal}

\def\restoreglobal
  {\let\redoglobal\@@redoglobal
   \let\dodoglobal\@@dodoglobal}

%D A very useful application of this macro is \type {\newif},
%D \TEX's fake boolean type. Not being a primitive,
%D \type {\global} hopelessly fails here. But a slight
%D adaption of Knuth's original macro permits:
%D
%D \starttyping
%D \doglobal\newif\iftest
%D \stoptyping
%D
%D Of course one can still say:
%D
%D \starttyping
%D \global\testtrue
%D \global\testfalse
%D \stoptyping
%D
%D Apart from the prefixes, a few more \type{\expandafters}
%D are needed:

% TODO: doesn't work now
% \def\newif#1%
%   {\scratchcounter\escapechar
%    \escapechar\minusone
%    \expandafter\expandafter\expandafter
%      \redoglobal\expandafter\expandafter\expandafter
%        \edef\@if#1{true}{\let\noexpand#1\noexpand\iftrue}%
%    \expandafter\expandafter\expandafter
%      \redoglobal\expandafter\expandafter\expandafter
%        \edef\@if#1{false}{\let\noexpand#1\noexpand\iffalse}%
%    \dodoglobal\@if#1{false}%
%    \escapechar\scratchcounter}

%D \macros
%D   {newconditional,
%D    settrue, setfalse,
%D    ifconditional,then}
%D
%D \TEX's lacks boolean variables, although the \PLAIN\ format
%D implements \type{\newif}. The main disadvantage of this
%D scheme is that it takes three hash table entries. A more
%D memory saving alternative is presented here. A conditional
%D is defined by:

\def\settrue #1{\chardef#1\zerocount}
\def\setfalse#1{\chardef#1\plusone}

\let\newconditional = \setfalse
\let\ifconditional  = \ifcase

\let\then\relax % so that we can say \ifnum1>2\then -)

%>> New \newif and globals (end) —————————————————————————————————— >>
%<< —— Robust grouped commands ———————————————————————————————————— >>

\long\def\HandleGroup#1#2%
  {\bgroup
   \long\def\BeforeGroup{\bgroup#1\bgroup\aftergroup\AfterGroup}%
   \long\def\AfterGroup {#2\egroup\egroup}%
   \afterassignment\BeforeGroup
   \let\next=}

\long\def\HandleSimpleGroup#1#2% no inner group (so no kerning interference)
  {\bgroup
   %long\def\BeforeGroup{\bgroup#1\aftergroup\AfterGroup}% interferes
   \long\def\BeforeGroup{\bgroup\aftergroup\AfterGroup#1}%
   \long\def\AfterGroup {#2\egroup}%
   \afterassignment\BeforeGroup
   \let\next=}

\long\def\HandleNoGroup#1#2%
  {\long\def\AfterGroup{#2\egroup}%
   \bgroup\aftergroup\AfterGroup#1}

\long\unexpanded\def\groupedcommand#1#2%
  {\doifnextbgroupelse{\HandleGroup{#1}{#2}}{\HandleNoGroup{#1}{#2}}}

\long\unexpanded\def\simplegroupedcommand#1#2%
  {\doifnextbgroupelse{\HandleSimpleGroup{#1}{#2}}{\HandleNoGroup{#1}{#2}}}

%>> Robust grouped commands (end) ————————————————————————————————— >>
%<< —— Pseudo counters ———————————————————————————————————————————— >>

%D \macros
%D   {newcounter,
%D    increment,decrement}
%D
%D Unfortunately the number of \COUNTERS\ in \TEX\ is limited,
%D but fortunately we can store numbers in a macro. We can
%D increment such pseudo \COUNTERS\ with \type{\increment}.
%D
%D \starttyping
%D \increment(\counter,20)
%D \increment(\counter,-4)
%D \increment(\counter)
%D \increment\counter
%D \stoptyping
%D
%D \starttyping
%D \ifnum\normalcounter=\pseudocounter \doif \else \doelse \fi
%D \ifnum\pseudocounter=\normalcounter \doif \else \doelse \fi
%D \stoptyping
%D
%D In the first test, \TEX\ continues it's search for the
%D second number after reading  \type{\pseudocounter}, while
%D in the second test, it stops reading after having
%D encountered a real one. Tests like the first one therefore
%D can give unexpected results, for instance execution
%D of \type{\doif} even if both numbers are unequal.

\def\zerocountervalue{0}

\def\ctxnewcounter#1%
  {\dodoglobal\let#1\zerocountervalue}

\def\!!zerocount {0} % alongside \zerocount
\def\!!minusone {-1} % alongside \minusone
\def\!!plusone   {1} % alongside \plusone

\def\dodoindecrement#1(#2,#3)%
  {\ifx#2\undefined
     \redoglobal\let#2\zerocountervalue
   \else\ifx#2\relax % \csname...\endcsname
     \redoglobal\let#2\zerocountervalue
   \fi\fi
   \scratchcounter#3\relax
   \scratchcounter#1\scratchcounter
   \advance\scratchcounter#2\relax
   \dodoglobal\edef#2{\the\scratchcounter}}

\def\dodoincrement(#1%
  {\doifnextcharelse,{\dodoindecrement+(#1}{\dodoindecrement+(#1,1}}

\def\dododecrement(#1%
  {\doifnextcharelse,{\dodoindecrement-(#1}{\dodoindecrement-(#1,1}}

\def\doincrement#1% 10% faster alternative
  {\ifx#1\undefined
     \dodoglobal\let#1\!!plusone
   \else\ifx#1\relax % \csname...\endcsname
     \dodoglobal\let#1\!!plusone
   \else
     \fastincrement#1%
   \fi\fi}

\def\dodecrement#1% 10% faster alternative
  {\ifx#1\undefined
     \dodoglobal\let#1\!!minusone
   \else\ifx#1\relax % \csname...\endcsname
     \dodoglobal\let#1\!!minusone
   \else
     \fastdecrement#1%
   \fi\fi}

\def\fastdecrement#1% 50% faster alternative
  {\scratchcounter#1\advance\scratchcounter\minusone
   \dodoglobal\edef#1{\the\scratchcounter}}

\def\fastincrement#1% 50% faster alternative
  {\scratchcounter#1\advance\scratchcounter\plusone
   \dodoglobal\edef#1{\the\scratchcounter}}

\def\increment{\doifnextcharelse(\dodoincrement\doincrement}
\def\decrement{\doifnextcharelse(\dododecrement\dodecrement}

\def\incrementvalue#1{\expandafter\increment\csname#1\endcsname}
\def\decrementvalue#1{\expandafter\decrement\csname#1\endcsname}

%D \macros
%D   {makecounter,pluscounter,minuscounter,
%D    resetcounter,setcounter,countervalue}
%D
%D Declaring, setting and resetting \COUNTERS\ can be doen
%D with the next set of commands.
%D
%D \starttyping
%D \makecounter   {name}
%D \pluscounter   {name}
%D \minuscounter  {name}
%D \resetcounter  {name}
%D \setcounter    {name} {value}
%D \countervalue  {name}
%D \stoptyping
%D
%D We prefer the use of global counters. This means that we
%D have to load \PLAIN\ \TEX\ in a bit different way:
%D
%D \starttyping
%D \let\oldouter=\outer
%D \let\outer=\relax
%D \input plain.tex
%D \let\outer=\oldouter
%D
%D \def\newcount%
%D   {\alloc@0\count\countdef\insc@unt}
%D \stoptyping
%D
%D First we show a solution in which we use real \COUNTERS.
%D Apart from some expansion, nothing special is done.
%D
%D \starttyping
%D \def\makecounter#1%
%D   {\expandafter\newcount\csname#1\endcsname}
%D
%D \def\pluscounter#1%
%D   {\global\advance\csname#1\endcsname by 1 }
%D
%D \def\minuscounter#1%
%D   {\global\advance\csname#1\endcsname by -1 }
%D
%D \def\resetcounter#1%
%D   {\expandafter\global\csname#1\endcsname=0 }
%D
%D \def\setcounter#1#2%
%D   {\expandafter\global\csname#1\endcsname=#2 }
%D
%D \def\countervalue#1%
%D   {\the\getvalue{#1}}
%D \stoptyping
%D
%D Because these macros are already an indirect way of working
%D with counters, there is no harm in using pseudo \COUNTERS\
%D here:

\def\makecounter#1%
  {\letgvalue{#1}\zerocountervalue} % see earlier

% \def\countervalue#1%
%   {\getvalue{#1}}

\let\countervalue\getvalue

\def\pluscounter#1%
  {\scratchcounter\getvalue{#1}%
   \advance\scratchcounter \plusone
   \setxvalue{#1}{\the\scratchcounter}}

\def\minuscounter#1%
  {\scratchcounter\getvalue{#1}%
   \advance\scratchcounter \minusone
   \setxvalue{#1}{\the\scratchcounter}}

\def\resetcounter#1%
  {\letgvalue{#1}\zerocountervalue}

\def\setcounter#1#2% or: \setxvalue{#1}{\number#2}
  {\scratchcounter#2%
   \setxvalue{#1}{\the\scratchcounter}}

\def\incrementcounter#1#2% #1 name #2 value
   {\setxvalue{#1}{\the\numexpr\csname#1\endcsname+#2\relax}}

\def\decrementcounter#1#2% #1 name #2 value
   {\setxvalue{#1}{\the\numexpr\csname#1\endcsname-#2\relax}}

%D \macros
%D   {savecounter,restorecounter}
%D
%D These two commands can be used to save and restore counter
%D values. Only one level is saved.

\def\savecounter#1%
  {{\scratchcounter\getvalue {#1}\setxvalue{!#1}{\the\scratchcounter}}}

\def\restorecounter#1%
  {{\scratchcounter\getvalue{!#1}\setxvalue {#1}{\the\scratchcounter}}}

%>> Pseudo counters (end) ————————————————————————————————————————— >>
%<< —— Loops —————————————————————————————————————————————————————— >>

%D \macros
%D   {dorecurse,recurselevel,recursedepth,
%D    dostepwiserecurse,
%D    for}
%D
%D \TEX\ does not offer us powerfull for||loop mechanisms. On
%D the other hand its recursion engine is quite unique. We
%D therefore identify the for||looping macros by this method.
%D The most simple alternative is the one that only needs a
%D number.
%D
%D \starttyping
%D \dorecurse {n} {whatever we want}
%D \stoptyping
%D
%D This macro can be nested without problems and therefore be
%D used in situations where \PLAIN\ \TEX's \type{\loop} macro
%D ungracefully fails. The current value of the counter is
%D available in \type{\recurselevel}, before as well as after
%D the \typ{whatever we wat} stuff.
%D
%D \starttyping
%D \dorecurse               % inner loop
%D   {10}
%D   {\recurselevel:          % outer value
%D      \dorecurse          % inner loop
%D        {\recurselevel}     % outer value
%D        {\recurselevel}     % inner value
%D      \dorecurse          % inner loop
%D        {\recurselevel}     % outer value
%D        {\recurselevel}     % inner value
%D    \endgraf}
%D \stoptyping
%D
%D In this example the first, second and fourth
%D \type{\recurselevel} concern the outer loop, while the third
%D and fifth one concern the inner loop. The depth of the
%D nesting is available for inspection in \type{\recursedepth}.
%D
%D Both \type{\recurselevel} and \type{\recursedepth} are
%D macros. The real \COUNTERS\ are hidden from the user because
%D we don't want any interference.

\newcount\outerrecurse
\newcount\innerrecurse

\def\recursedepth{\the\outerrecurse}
\def\recurselevel{0}

\let\nextrecurse\relax

\def\@@irecurse{@@ir@@} % ecurse} % stepper
\def\@@arecurse{@@ar@@} % ecurse} % action

% \mathchardef

\long\def\dostepwiserecurse#1#2#3#4% can be made faster by postponing #4
  {\global\advance\outerrecurse \plusone
   \long\global\@EA\def\csname\@@arecurse\recursedepth\endcsname{#4}%
   \global\@EA\let\csname\@@irecurse\recursedepth\endcsname\recurselevel
   \ifnum#3>0\relax
     \ifnum#2<#1\relax
       \let\nextrecurse\exitstepwiserecurse
     \else
       \let\nextrecurse\dodostepwiserecurse
     \fi
   \else
     \ifnum#3<0\relax
       \ifnum#1<#2\relax
         \let\nextrecurse\exitstepwiserecurse
       \else
         \let\nextrecurse\dodostepwisereverse
       \fi
     \else
       \let\nextrecurse\exitstepwiserecurse
     \fi
   \fi\expanded{\nextrecurse{\number#1}{\number#2}{\number#3}}}

\long\def\dodostepwiserecurse#1#2#3% from to step
  {\ifnum#1>#2\relax
     \@EA\nodostepwiserecurse
   \else
     \def\recurselevel{#1}%
     \innerrecurse#1\advance\innerrecurse#3\relax
     \@EAEAEA\redostepwiserecurse\@EA
   \fi\@EA{\the\innerrecurse}{#2}{#3}}

\def\expandrecursecontent
  {\csname\@@arecurse\recursedepth\endcsname}

\def\redostepwiserecurse
  {\expandrecursecontent\dodostepwiserecurse}

\long\def\dodostepwisereverse#1#2#3% from to step
  {\ifnum#1<#2\relax
     \@EA\nodostepwiserecurse
   \else
     \def\recurselevel{#1}%
     \innerrecurse#1\relax
     \advance\innerrecurse#3\relax
     \@EAEAEA\redostepwisereverse\@EA
   \fi\@EA{\the\innerrecurse}{#2}{#3}}

\def\redostepwisereverse
  {\expandrecursecontent\dodostepwisereverse}

\def\exitstepwiserecurse
  {\nodostepwiserecurse\relax}

\def\nodostepwiserecurse#1#2#3#4%
  {\@EA\let\@EA\recurselevel\csname\@@irecurse\recursedepth\endcsname
   \global\advance\outerrecurse \minusone}

\def\nonostepwiserecurse#1#2#3%
  {\@EA\let\@EA\recurselevel\csname\@@irecurse\recursedepth\endcsname
   \global\advance\outerrecurse \minusone}

\def\dorecurse#1%
  {\dostepwiserecurse1{#1}1}

%D As we can see here, the simple command \type{\dorecurse} is
%D a special case of the more general:
%D
%D \starttyping
%D \dostepwiserecurse {from} {to} {step} {action}
%D \stoptyping
%D
%D This commands accepts positive and negative steps. Illegal
%D values are handles as good as possible and the macro accepts
%D numbers and \COUNTERS.
%D
%D \starttyping
%D \dostepwiserecurse  {1} {10}  {2} {...}
%D \dostepwiserecurse {10}  {1} {-2} {...}
%D \stoptyping
%D
%D Because the simple case is used often, we implement it
%D more efficiently:

\long\def\dorecurse#1%
  {\ifcase#1\relax
     \expandafter\gobbletwoarguments
   \or
     \expandafter\ydorecurse
   \else
     \expandafter\xdorecurse
   \fi{#1}}

\long\def\xdorecurse#1#2%
  {\global\advance\outerrecurse \plusone
   \long\global\@EA\def\csname\@@arecurse\recursedepth\endcsname{#2}%
   \global\@EA\let\csname\@@irecurse\recursedepth\endcsname\recurselevel
   \@EA\dodorecurse\@EA1\@EA{\number#1}}

\long\def\ydorecurse#1#2%
  {\global\advance\outerrecurse \plusone
   \global\@EA\let\csname\@@irecurse\recursedepth\endcsname\recurselevel
   \let\recurselevel\!!plusone
   #2%
   \@EA\let\@EA\recurselevel\csname\@@irecurse\recursedepth\endcsname
   \global\advance\outerrecurse \minusone}

\long\def\dodorecurse#1#2% from to
  {\ifnum#1>#2\relax
     \@EA\nodorecurse
   \else
     \def\recurselevel{#1}%
     \innerrecurse#1\advance\innerrecurse\plusone
     \@EAEAEA\redorecurse
   \fi\@EA{\the\innerrecurse}{#2}}

\def\redorecurse
  {\expandrecursecontent\dodorecurse}

\def\nodorecurse#1#2#3%
  {\@EA\let\@EA\recurselevel\csname\@@irecurse\recursedepth\endcsname
   \global\advance\outerrecurse \minusone }

%D \macros
%D   {doloop,exitloop}
%D
%D Sometimes loops are not determined by counters, but by
%D (a combinations of) conditions. We therefore implement a
%D straightforward loop, which can only be left when we
%D explictly exit it. Nesting is supported. First we present
%D a more extensive alternative.
%D
%D \starttyping
%D \doloop
%D   {Some kind of typesetting punishment \par
%D    \ifnum\pageno>100 \exitloop \fi}
%D \stoptyping
%D
%D When needed, one can call for \type{\looplevel} and
%D \type{\loopdepth}.

\let\endofloop\donothing

\long\def\doloop#1%
  {\global\advance\outerrecurse \plusone
   \long\global\@EA\def\csname\@@arecurse\recursedepth\endcsname{#1}%
   \global\@EA\let\csname\@@irecurse\recursedepth\endcsname\recurselevel
   \let\endofloop\dodoloop
   \dodoloop1} % no \plusone else \recurselevel wrong

\long\def\dodoloop#1%
  {\def\recurselevel{#1}%
   \innerrecurse#1\advance\innerrecurse\plusone
   \@EA\redoloop\@EA{\the\innerrecurse}}

\def\redoloop
  {\expandrecursecontent\endofloop}

\def\nodoloop#1%
  {\let\endofloop\dodoloop % new, permits nested \doloop's
   \@EA\let\@EA\recurselevel\csname\@@irecurse\recursedepth\endcsname
   \global\advance\outerrecurse\minusone}

\def\exitloop                     % \exitloop quits at end
  {\let\endofloop\nodoloop}

\long\def\exitloopnow#1\endofloop % \exitloopnow quits directly
  {\nodoloop}

%D The loop is executed at least once, so beware of situations
%D like:
%D
%D \starttyping
%D \doloop {\exitloop some commands}
%D \stoptyping
%D
%D It's just a matter of putting the text into the \type{\if}
%D statement that should be there anyway, like in:
%D
%D \starttyping
%D \doloop {\ifwhatever \exitloop \else some commands\fi}
%D \stoptyping
%D
%D You can also quit a loop immediately, by using \type
%D {\exitloopnow} instead. Beware, this is more sensitive
%D for conditional errors.

\def\expandrecursecontent
  {\csname\@@arecurse\recursedepth\@EA\@EA\@EA\endcsname\@EA\@EA\@EA{\@EA\recurselevel\@EA}\@EA{\recursedepth}}

\long\def\xdorecurse#1#2%
  {\global\advance\outerrecurse \plusone
   \long\global\@EA\def\csname\@@arecurse\recursedepth\endcsname##1##2{#2}%
   \global\@EA\let\csname\@@irecurse\recursedepth\endcsname\recurselevel
   \@EA\dodorecurse\@EA1\@EA{\number#1}}

\long\def\ydorecurse#1#2%
  {\global\advance\outerrecurse \plusone
   \global\@EA\let\csname\@@irecurse\recursedepth\endcsname\recurselevel
   \let\recurselevel\!!plusone
   \long\global\@EA\def\csname\@@arecurse\recursedepth\endcsname##1##2{#2}%
   \expandrecursecontent
   \@EA\let\@EA\recurselevel\csname\@@irecurse\recursedepth\endcsname
   \global\advance\outerrecurse \minusone}

\long\def\dostepwiserecurse#1#2#3#4% can be made faster by postponing #4
  {\global\advance\outerrecurse \plusone
   \long\global\@EA\def\csname\@@arecurse\recursedepth\endcsname##1##2{#4}%
   \global\@EA\let\csname\@@irecurse\recursedepth\endcsname\recurselevel
   \ifnum#3>0\relax
     \ifnum#2<#1\relax
       \let\nextrecurse\exitstepwiserecurse
     \else
       \let\nextrecurse\dodostepwiserecurse
     \fi
   \else
     \ifnum#3<0\relax
       \ifnum#1<#2\relax
         \let\nextrecurse\exitstepwiserecurse
       \else
         \let\nextrecurse\dodostepwisereverse
       \fi
     \else
       \let\nextrecurse\exitstepwiserecurse
     \fi
   \fi\expanded{\nextrecurse{\number#1}{\number#2}{\number#3}}}

\long\def\doloop#1%
  {\global\advance\outerrecurse \plusone
   \long\global\@EA\def\csname\@@arecurse\recursedepth\endcsname##1##2{#1}%
   \global\@EA\let\csname\@@irecurse\recursedepth\endcsname\recurselevel
   \let\endofloop\dodoloop
   \dodoloop1} % no \plusone else \recurselevel wrong

%D For special purposes:

\newcount\fastrecursecounter
\newcount\lastrecursecounter
\newcount\steprecursecounter

\def\dofastrecurse#1#2#3#4%
  {\def\fastrecursebody{#4}%
   \fastrecursecounter#1\relax
   \lastrecursecounter#2\relax
   \steprecursecounter#3\relax
   \def\recurselevel{\number\fastrecursecounter}%
   \dodofastrecurse}

\def\resetrecurselevel{\let\recurselevel\!!zerocount}

\def\dodofastrecurse
  {\ifnum\fastrecursecounter>\lastrecursecounter
     % \resetrecurselevel % slows down
   \else
     \fastrecursebody
     \advance\fastrecursecounter\steprecursecounter
     \expandafter\dodofastrecurse
   \fi}

% \appendtoks \resetrecurselevel \to \everydump

\newtoks\everydump
\everydump\expandafter{\the\everydump\resetrecurselevel}

%D This alternative looks a bit different and uses a
%D pseudo counter. When this macro is nested, we have to use
%D different counters. This time we use keywords.
%D
%D \starttyping
%D \def\alfa{2} \def\beta{100} \def\gamma{3}
%D
%D \for \n=55    \to 100   \step  1      \do {... \n ...}
%D \for \n=\alfa \to \beta \step  \gamma \do {... \n ...}
%D \for \n=\n    \to 120   \step  1      \do {... \n ...}
%D \for \n=120   \to 100   \step -3      \do {... \n ...}
%D \for \n=55    \to 100   \step  2      \do {... \n ...}
%D \stoptyping
%D
%D Only in the third example we need to predefine \type{\n}.
%D The use of \type{\od} as a dilimiter would have made nested
%D use more problematic.

%D Don't use this one, it's kind of obsolete.

\def\for#1=#2\to#3\step#4\do#5%
  {\dostepwiserecurse{#2}{#3}{#4}
     {\let#1\recurselevel#5\let#1\recurselevel}}

%>> Loops (end) ——————————————————————————————————————————————————— >>
%<< —— Convert into strings ——————————————————————————————————————— >>

%D \macros
%D   {convertargument,convertcommand,convertvalue}
%D
%D Some persistent experimenting led us to the next macro. This
%D macro converts a parameter or an expanded macro to it's
%D textual meaning.
%D
%D \starttyping
%D \convertargument ... \to \command
%D \stoptyping
%D
%D For example,
%D
%D \starttyping
%D \convertargument{one \two \three{four}}\to\ascii
%D \stoptyping
%D
%D The resulting macro \type{\ascii} can be written to a file
%D or the terminal without problems. In \CONTEXT\ we use this
%D macro for generating registers and tables of contents.
%D
%D The second conversion alternative accepts a command:
%D
%D \starttyping
%D \convertcommand\command\to\ascii
%D \stoptyping
%D
%D Both commands accept the prefix \type{\doglobal} for global
%D assignments.

\def\doconvertargument#1>{}

\def\convertedcommand
  {\expandafter\doconvertargument\meaning}

\long\def\convertargument#1\to#2%
  {\long\def#2{#1}% saves a restore
   \dodoglobal\edef#2{\convertedcommand#2}}

\long\def\convertcommand#1\to#2%
  {\dodoglobal\edef#2{\convertedcommand#1}}

% no dodoglobal !

\long\def\defconvertedargument#1#2% less sensitive for \to
  {\long\def#1{#2}% saves a restore
   \edef#1{\convertedcommand#1}}

\long\def\defconvertedcommand#1#2% less sensitive for \to
  {\edef#1{\convertedcommand#2}}

\long\def\gdefconvertedargument#1#2% less sensitive for \to
  {\long\gdef#1{#2}% saves a restore
   \xdef#1{\convertedcommand#1}}

\long\def\gdefconvertedcommand#1#2% less sensitive for \to
  {\xdef#1{\convertedcommand#2}}

\def\convertvalue#1\to
  {\expandafter\convertcommand\csname#1\endcsname\to}

\def\defconvertedvalue#1#2% less sensitive for \to
  {\@EA\defconvertedcommand\@EA#1\csname#2\endcsname}

%>> Convert into strings (end) ———————————————————————————————————— >>
%<< —— Setlocalhsize —————————————————————————————————————————————— >>

%D \macros
%D   {setlocalhsize}
%D
%D Sometimes we need to work with the \type{\hsize} that is
%D corrected for indentation and left and right skips. The
%D corrected value is available in \type{\localhsize}, which
%D needs to be calculated with \type{\setlocalhsize} first.
%D
%D \starttyping
%D \setlocalhsize        \hbox to \localhsize{...}
%D \setlocalhsize[-1em]  \hbox to \localhsize{...}
%D \setlocalhsize[.5ex]  \hbox to \localhsize{...}
%D \stoptyping
%D
%D These examples show us that an optional can be used. The
%D value provided is added to \type{\localhsize}.

\newdimen\localhsize

\def\setlocalhsize{\doifnextoptionalelse\dosetlocalhsize{\dosetlocalhsize[\zeropoint]}}
\def\dolocalhsize[#1]% don't change !
  {\localhsize\hsize
   \ifnum\hangafter<\zerocount
     \advance\localhsize\ifdim\hangindent>\zeropoint-\fi\hangindent
   \fi
   \advance\localhsize -\leftskip
   \advance\localhsize -\rightskip
   \advance\localhsize #1\relax}

%>> Setlocalhsize (end) ——————————————————————————————————————————— >>
%<< —— dontleavehmode ————————————————————————————————————————————— >>

%D \macros
%D  {dontleavehmode}
%D
%D Sometimes when we enter a paragraph with some command, the
%D first token gets the whole first line. We can prevent this
%D by saying:
%D
%D \starttyping
%D \dontleavehmode
%D \stoptyping

\newbox\@@dlhbox

\unexpanded \def\dontleavehmode
  {\ifhmode\else \ifmmode\else
     \setbox\@@dlhbox\hbox{\mathsurround\zeropoint\everymath\emptytoks$ $}\unhbox\@@dlhbox
   \fi \fi}

\ifx\normalquitvmode\undefined \else \let\dontleavehmode\normalquitvmode \fi

%>> dontleavehmode (end) —————————————————————————————————————————— >>
%<< —— Write strings —————————————————————————————————————————————— >>

%D \macros
%D   {writestring,writeline,writebanner,
%D    writestatus,statuswidth,normalwritestatus}
%D
%D Maybe one didn't notice, but we've already introduced a
%D macro for showing messages. In the multi||lingual modules,
%D we will also introduce a mechanism for message passing. For
%D the moment we stick to the core macros:
%D
%D \starttyping
%D \writestring {string}
%D \writeline
%D \writestatus {category} {message}
%D \stoptyping
%D
%D Messages are formatted. One can provide the maximum with
%D of the identification string with the macro \type
%D {\statuswidth}.

\chardef\statuswidth=15
\chardef\statuswrite=16

\ifx\writestring\undefined

    \newtoks\everywritestring

    \def\writedirect  {\immediate\write\statuswrite}
    \def\writeline    {\writedirect{}}
    \def\writestring#1{\begingroup\the\everywritestring\writedirect{#1}\endgroup}

\fi

%D First we present the normal \TEX\ variant, later we will
%D show the \ETEX-way.

    \newcount\statuscounter

    \def\dosplitstatus#1%
      {\advance\statuscounter \minusone
       \ifcase\statuscounter
         \expandafter\nosplitstatus
       \else
         \scratchtoks\@EA{\the\scratchtoks#1}%
         \expandafter\dosplitstatus
       \fi}

    \def\nosplitstatus#1\end
      {}

    \def\writestatus#1#2%
      {\begingroup
       \scratchtoks\emptytoks
       \statuscounter\statuswidth
       \expandafter\dosplitstatus#1%
         \space\space\space\space\space\space\space
         \space\space\space\space\space\space\space
         \space\space\space\space\space\space\end
       \@EA\writestring\@EA{\the\scratchtoks\space:\space#2}%
       \endgroup}

%D Okay then, more obscure but slightly faster: no split grabs
%D the do split part and skipping the else branch has to happen
%D anyway, so:

    \def\dosplitstatus#1%
      {\advance\statuscounter \minusone
       \ifcase\statuscounter
         \expandafter\nosplitstatus
       \fi
       \scratchtoks\@EA{\the\scratchtoks#1}%
       \dosplitstatus}

%D \macros
%D   {emptytoks}
%D
%D For this we need an empty token register, analogous
%D to \type {\empty}.

\newtoks\emptytoks

%D \macros
%D   {debuggerinfo}
%D
%D For debugging purposes we can enhance macros with the
%D next alternative. Here \type{debuggerinfo} stands for both
%D a macro accepting two arguments and a boolean (in fact a
%D few macro's too).

\newif\ifdebuggerinfo

\def\debuggerinfo#1#2%
  {\ifdebuggerinfo
     \writestatus{debugger}{#1:: #2}%
   \fi}

%D Finally we do what from now on will be done at the top of
%D the files: we tell the user what we are loading.

% \ifx\writestatus\undefined \let\writestatus\normalwritestatus \fi
% \ifx\writebanner\undefined \def\writebanner{\writestring}     \fi

\ifx\normalwritestatus\undefined
    % for use within latex
    \ifx\writestatus\undefined
        \def\writestatus#1#2{\immediate\write16{#1 : #2}}
    \fi
\else
    \let\writestatus\normalwritestatus
\fi

\def\writebanner{\writestring}

%>> Write strings (end) ——————————————————————————————————————————— >>

%D \macros
%D   {strutdp,strutht,strutwd}
%D
%D The next shortcuts save memory and keying. The width is
%D normally zero points (if not, you're in trouble). These
%D shortcuts can be used like a dimension, opposite to the
%D core macros \type {\strutdepth} and alike, which are
%D values.

\def\strutdp{\dp\strutbox}
\def\strutht{\ht\strutbox}
\def\strutwd{\wd\strutbox}

%D \macros
%D   {resetbox, emptybox}
%D
%D Let's start with an easy one. The next macro hides the
%D ugly \type {@} in \type {\voidb@x}.

\ifx\voidbox\undefined      \newbox\voidbox \fi
\ifx\voidb@x\undefined \let\voidb@x\voidbox \fi

\def\emptybox  {\box   \voidbox}
\def\unvoidbox {\unhbox\voidbox}
\def\resetbox#1{\setbox#1\box\voidbox}

%D \macros
%D   {nextdepth}
%D
%D Let's start with a rather simple declaration. Sometimes we
%D need to save the \TEX\ \DIMENSION\ \type{\prevdepth} and
%D append it later on. The name \type{\nextdepth} suits
%D this purpose well.

\newdimen\nextdepth

%D \macros
%D   {dowithnextbox,nextbox}
%D
%D Sometimes we want a macro to grab a box and do something
%D on the content. One could pass an argument to a box, but
%D this can violate the specific \CATCODES\ of its content and
%D leads to unexpected results. The next macro treats the
%D following braced text as the content of a box and
%D manipulates it afterwards in a predefined way.
%D
%D The first argument specifies what to do with the content.
%D This content is available in \type{\nextbox}. The second
%D argument is one of \type{\hbox}, \type{\vbox} or
%D \type{\vtop}. The third argument must be grouped with
%D \type{\bgroup} and \type{\egroup}, \type{{...}} or can be
%D a \type{\box} specification.
%D
%D In \CONTEXT\ this macro is used for picking up a box and
%D treating it according to earlier specifications. We use for
%D instance something like:
%D
%D \starttyping
%D \def\getfloat%
%D   {\def\handlefloat{...\flushnextbox...}
%D    \dowithnextbox\handlefloat\normalvbox}
%D \stoptyping
%D
%D instead of:
%D
%D \starttyping
%D \def\getfloat#1%
%D   {...#1...}
%D \stoptyping
%D
%D In this implementation the \type{\aftergroup} construction
%D is needed because \type{\afterassignment} is executed inside
%D the box.

\ifx\nextbox\undefined \newbox\nextbox \fi

\long\def\dowithnextbox#1%
  {\long\def\dodowithnextbox{#1}%
   \afterassignment\dododowithnextbox
   \setbox\nextbox}

\def\dododowithnextbox
  {\aftergroup\dodowithnextbox}

\long\def\dowithnextboxcs#1%
  {\let\dodowithnextbox#1%
   \afterassignment\dododowithnextbox
   \setbox\nextbox}

\def\dododowithnextbox
  {\aftergroup\dodowithnextbox}

%D So in fact we get:
%D
%D \starttyping
%D \setbox\nextbox { \aftergroup\dodowithnextbox ... }
%D \stoptyping
%D
%D or
%D
%D \starttyping
%D \setbox\nextbox { ... } \dodowithnextbox
%D \stoptyping
%D
%D A slower but more versatile implementation is:
%D
%D \starttyping
%D \long\def\dowithnextbox#1#2%
%D   {\long\def\dodowithnextbox{#1}%
%D    \ifx#2\normalhbox
%D      \afterassignment\dododowithnextbox
%D    \else\ifx#2\normalvbox
%D      \afterassignment\dododowithnextbox
%D    \else\ifx#2\normalvtop
%D      \afterassignment\dododowithnextbox
%D    \else\ifx#2\normalvcenter
%D      \afterassignment\dododowithnextbox
%D    \else
%D      \afterassignment\dodowithnextbox
%D    \fi\fi\fi\fi
%D    \setbox\nextbox#2}
%D \stoptyping
%D
%D This alternative also accepts \type{\box0} and alike, but
%D we don't really need this functionality now.

%D \macros
%D   {nextboxht,nextboxwd,nextboxdp,flushnextbox}
%D
%D The next couple of shortcuts saves us memory as well as
%D \type {{}}'s in passing parameters.

\def\nextboxht{\ht\nextbox}
\def\nextboxwd{\wd\nextbox}
\def\nextboxdp{\dp\nextbox}

\def\flushnextbox{\box\nextbox}

%D \macros
%D   {dowithnextboxcontent}
%D
%D But, occasionally we do need to pass some local settings
%D without wanting to use additional grouping. Therefore we
%D provide:
%D
%D \starttyping
%D \dowithnextboxcontent{inside}{after}{box content}
%D \stoptyping
%D
%D {\em todo: Search source for potential usage!}

\long\def\dowithnextboxcontent#1#2% inside, after
  {\long\def\dodowithnextbox{#2}%
   \def\dododowithnextbox{#1\aftergroup\dodowithnextbox}%
   \afterassignment\dododowithnextbox
   \setbox\nextbox}

\protect


%%% Local Variables:
%%% TeX-master: "demo"
%%% End:
